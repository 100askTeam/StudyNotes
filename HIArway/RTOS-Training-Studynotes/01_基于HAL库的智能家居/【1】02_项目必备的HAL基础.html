<html>
<head>
  <title>【1】02_项目必备的HAL基础</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605138 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <meta name="content-class" content="yinxiang.superNote"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="2702"/>
<h1>【1】02_项目必备的HAL基础</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2022/3/2 19:57</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/5/13 19:50</i></td></tr>
<tr><td><b>作者：</b></td><td><i>gi51wa2j</i></td></tr>
<tr><td><b>标签：</b></td><td><i>bingo, RTOS训练营, 基于HAL的智能家居, 正文</i></td></tr>
</table>
</div>
<br/>

<div><span><h1>1.GPIO操作函数</h1><img src="【1】02_项目必备的HAL基础_files/Image.png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [1].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>2.流水灯和跑马灯的区别</h1><img src="【1】02_项目必备的HAL基础_files/Image [2].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>3.按键消抖</h1><img src="【1】02_项目必备的HAL基础_files/Image [3].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>4.CubeMx的硬件初始化函数</h1><img src="【1】02_项目必备的HAL基础_files/Image [4].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>引脚初始化状态也是在cubemx里面设置好的</div><img src="【1】02_项目必备的HAL基础_files/Image [5].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>5. OLED显示</h1><img src="【1】02_项目必备的HAL基础_files/Image [6].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [7].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [8].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="752px"/><img src="【1】02_项目必备的HAL基础_files/Image [9].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>6. STM32F103的GPIO模式</h1><img src="【1】02_项目必备的HAL基础_files/Image [10].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>7. 模拟I2C</h1><div>// IIC发送1字节数据（字节高位先传：MSB）</div><img src="【1】02_项目必备的HAL基础_files/Image [11].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>8.OLED显示格式</h1><img src="【1】02_项目必备的HAL基础_files/Image [12].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [13].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [14].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [15].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [16].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [17].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [18].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [19].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [20].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [21].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [22].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [23].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [24].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [25].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="text-align:center;"><span style="font-size: 14pt;"><b>这款oled显示，低位在前，高位在后，所以需要取字模软件</b></span></div><img src="【1】02_项目必备的HAL基础_files/Image [26].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [27].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [28].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [29].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [30].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [31].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>9.串行通信</h1><img src="【1】02_项目必备的HAL基础_files/Image [32].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [33].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [34].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [35].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [36].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [37].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [38].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>对于同步信号，可以通过调整时钟的频率，可以很快地提高数据传输的频率。</div><p>对于异步信号，要提前约定好速率，不能随意更改。</p><img src="【1】02_项目必备的HAL基础_files/Image [39].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [40].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [41].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [42].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [43].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [44].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [45].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [46].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [47].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [48].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><span style="font-size: 14pt;"><b>sizeof()函数包含结束符</b></span></div><div><span style="font-size: 14pt;"><b>strlen()函数不包含结束符\0</b></span></div><img src="【1】02_项目必备的HAL基础_files/Image [49].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><div><span style="font-size: 14pt;"><b>单片机编程的时候，应该可以使用所有的c库，keil编译器可以调用内部的库帮我们做处理，最终还是转化为机器码。</b></span></div><img src="【1】02_项目必备的HAL基础_files/Image [50].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>10.中断</h1><img src="【1】02_项目必备的HAL基础_files/Image [51].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [52].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [53].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [54].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [55].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [56].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [57].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [58].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><div><br/></div><div><br/></div><h1>11.环形缓冲区</h1><img src="【1】02_项目必备的HAL基础_files/Image [59].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [60].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [61].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [62].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [63].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【1】02_项目必备的HAL基础_files/Image [64].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>9.1 环形缓冲区状态（写满/空）理解</h2><h3>9.1.1 特征</h3><div>满或空，读写指针会出现在同一位置</div><h3>9.1.2分析</h3><div style="--en-callout:true;"><div><b>判断缓冲区是满还是空有多种方法，例如计数、保持一个存储单元为空、镜像指示位等，本文采用第二种方式：保持一个存储单元为空，</b><span style="background-color: #ffffff;"><span style="font-weight: 400;">缓冲区中总是有一个存储单元保持未使用状态。缓冲区最多存入</span></span><span style="font-weight: 400;">（size - 1）</span><span style="background-color: #ffffff;"><span style="font-weight: 400;"> 个数据。</span></span></div><div><span style="background-color: #ffffff;"><span style="font-weight: 400;">* </span></span>如果读写指针指向同一位置，则缓冲区为空。</div><div>* 如果写指针位于读指针的相邻后一个位置，则缓冲区为满。</div><div><span style="color: #9B00FF;"><span style="background-color: #ffffff;"><b><span style="font-weight: 400;">这种策略的优点是简单、鲁棒（稳定健壮）；缺点是语义上实际可存数据量与缓冲区容量不一致，测试缓冲区是否满需要做取余数计算。</span></b></span></span></div></div><div><br/></div><div><span style="color: #FF0000;"><b>因为缓冲区写满和为空的标志都是PR =pW ,所以我们需要把他们区分开来</b></span>。  1.对于缓冲区为空PR =Pw，没啥问题，  2.但是对于写满的话，我们分开理解，先判断PW是否达到了BUFFER_SIZE规定的最大大小，判断是否满足最大大小，我们采用取余的方式，如果两个数字相同，那么余数为0，不过不同的话，余数就是PW，现在问题又来了，这样和判断缓冲区为空的方式是一样的，所以我们<b>需要一个标志位来判断是否写满，也就是浪费的最后一位</b>，下面两种情况，  这个数组长度为8，当pw到达数组边界7的时候，需要让PW=0  （1）如果PW没有达到最大尺寸7，那么正常写入，这句话前面的判断就是</div><img src="【1】02_项目必备的HAL基础_files/1.jpg" type="image/jpeg" data-filename="1.jpg" style="--en-uploadstate:uploaded;"/><div>，就可以写入了。PR = PW是判断缓冲区为空或者为满的必要条件，而前面是用来判断PW写入这个数据后，PW被+1后，下一位是否为8（0）    （2）PW达到最大尺寸7，也就是数组下标7的位置，就是上一次写入了数组下标6，导致这次数组下标为7，那么当PW=7的时候，下一个PW就是8(即0) </div><img src="【1】02_项目必备的HAL基础_files/2.jpg" type="image/jpeg" data-filename="2.jpg" style="--en-uploadstate:uploaded;"/><div> 注意那个+1，区别了位置0并且使得PW写到第6位的时候，准备写第7位，这时判断了这是最后的一位，所以跳过，直接判断为满。</div><h2>9.2 环形缓冲区参考资料</h2><div><a href="https://blog.csdn.net/u013896064/article/details/108000000?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-108000000-blog-81984269.pc_relevant_antiscanv2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">环形缓冲区的理解</a></div><div><a href="https://blog.csdn.net/qq_28258885/article/details/118108746?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%99%E6%BB%A1%E5%92%8C%E4%B8%BA%E7%A9%BA&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-118108746.142^v9^control,157^v4^control&amp;spm=1018.2226.3001.4187">优秀的内存规划方法——环形缓冲区（ring buffer）</a></div><div><br/></div></span>
</div></body></html> 