<html>
<head>
  <title>【2】03四小时中度掌握FreeRTOS</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605138 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <meta name="content-class" content="yinxiang.superNote"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="4524"/>
<h1>【2】03四小时中度掌握FreeRTOS</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2022/5/5 21:42</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/5/9 9:58</i></td></tr>
<tr><td><b>作者：</b></td><td><i>gi51wa2j</i></td></tr>
<tr><td><b>标签：</b></td><td><i>bingo, FreeRTOS快速入门, RTOS训练营, 正文</i></td></tr>
</table>
</div>
<br/>

<div><span><h1>1.主要内容与学习目的</h1><h2>1.1 内容</h2><ul><li><p>栈作用演示</p></li><li><p>创建任务的2个核心：栈、任务结构体</p></li><li><p>任务调度机制</p></li><li><p>基于链表理解调度机制</p></li><li><p>队列的使用</p></li><li><p>基于链表理解队列</p></li></ul><h2>1.2 学习目的</h2><div>中度掌握——知道内部机制</div><h2>1.3 RTOS与裸机程序的区别</h2><div>核心在于：任务的交替执行</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image.png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>1.4 后续例程所使用文件</h2><div>备用：并无高端技巧，该文件在STM32F103上搭建好环境方便测试而已。</div><a href="【2】03四小时中度掌握FreeRTOS_files/11_freertos_example_scheduler.zip"><img src="【2】03四小时中度掌握FreeRTOS_files/3646bdc8441deba2e75e96af47362b9e.png" alt="11_freertos_example_scheduler.zip"></a><h1>2.概念理解</h1><div><b>任务：</b>本质就是一个运行起来的函数，包含信息有：一段保存在flash上的代码（无法更改）、任务运行的位置、任务运行的环境（各种局部变量）。</div><div>函数引申出下列的问题，任务切换时会暂停任务，那么<b>如何暂停任务并且恢复任务</b></div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [1].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="307px"/><div><b>怎么暂停/恢复任务，需要保存哪些东西：</b>任务执行的位置，变量的值不能被破坏以及其他一些需要注意的事项。</div><h2>2.1 函数运行环境理解示例</h2><div>通过add_val函数理解函数运行过程中<b>如果被打断，需要保存哪些东西，理解函数运行的本质。</b>并且理解需要<b>哪些东西才可以让这个函数恢复运行。</b></div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [2].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="567px"/><div>通过Keil工具查看add_val函数的反汇编代码，进行分析</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [3].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>2.1.1 ARM架构基础知识补充（以F103为例）</h3><img src="【2】03四小时中度掌握FreeRTOS_files/Image [4].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="323px"/><ul><li><div>CPU与内存的关系，计算a+b的过程</div></li></ul><div>读a、读b、计算a+b、写入a+b</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [5].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="493.2900006854064px"/><div><b>CPU从内存中将数据读到哪里？CPU内部有多个寄存器，读入的数据保存在CPU内部寄存器中</b></div><div><b>CPU如何读取数据？需要知道源、目的、长度</b></div><div><b>CPU怎么知道执行这样的一个操作来对数据进行执行？CPU读Flash得到指令，执行读取内存的指令</b></div><div><b>CPU如何知道要将读取的数据放到哪一个CPU内部寄存器呢？CPU不知道，它所有操作都是从程序中读取出来的，程序告诉它保存在哪，这些指令叫做机器码</b></div><h3>2.1.2 汇编代码讲解</h3><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div><span style="color: #FF0000;"><b>函数开始，假设刚开始sp=addr1</b></span></div></div><ul><li><div><b>PUSH {r3, lr}</b></div></li></ul><div>PUSH指令本质是一条写内存指令，将R3和Lr寄存器的值放入栈中。</div><div>lr等于当前程序的返回地址，也就是下一条指令prvsetupHardware()函数的地址。</div><div>栈的地址由sp指针决定，<b>高标号的寄存器放在高地址，低标号寄存器在低地址</b>，即括号里面的内容没有序号的排放也可以。</div><div>假设sp（R13）为addr1，那么效果图如下</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [6].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="279px"/><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div><span style="color: #FF0000;"><b>temp = *pa</b></span></div></div><ul><li><div><b>LDR r2,[r0,#0x00]</b></div></li></ul><div>在调用C函数的时候，有约定少于四个参数的函数的形参，第一个参数保存在r0，第二个参数保存在r1，第三个参数保存在r2，第四个参数保存在r3。</div><div>因此，这里的R0=&amp;a=a的地址，这条指令的意义在于去a的地址读取数据，保存在R2里面，R2寄存器的值目前是&amp;a的值偏移地址0位所在地址读取到的值。<b>R2 = a.</b></div><ul><li><div><b>STR r2,[sp,#0x00]</b></div></li></ul><div>将R2，放到sp+0所在的地址上，这会[sp+ 0x00]地址的值充当一个Temp临时变量</div><div>temp = [sp + 0x00] = a</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [7].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="287.39737108190087px"/><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div><span style="color: #FF0000;"><b>temp=temp+*pb</b></span></div></div><ul><li><div><b>LDR r2,[r1,#0x00]</b></div></li></ul><div>R2 = [R1+0x00] = [&amp;b] = b</div><ul><li><div><b>LDR r3,[sp,#0x00]</b></div></li></ul><div>R3 =[sp + 0x00] = temp = a </div><ul><li><div><b>ADD r2,r2,r3;</b></div></li></ul><div>R2 = R2 + R3 = b +  temp </div><ul><li><div><b>STR r2,[sp,#0x00]</b></div></li></ul><div>[sp + 0x00] = R2 = b + temp</div><div>即，temp = temp + *pb</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div><span style="color: #FF0000;"><b>*pa=temp</b></span></div></div><ul><li><div><b>LDR r2,[sp,#0x00]</b></div></li></ul><div>将[sp+ 0x00]地址的值读取到R2</div><div>即：R2 = [sp +0x00] = temp</div><ul><li><div><b>STR r2,[r0,#0x00]</b></div></li></ul><div>将R2的值存放到[sp + 0x00]的地址</div><div>即<span style="color: #000000;">[sp + 0x00 ]  =  R2 = temp，此时[sp+0x00]地址所存放的值是运算的结果</span></div><ul><li><div><b>POP {r3, pc}</b></div></li></ul><div>POP本质是一条读内存的指令，这里从内存中读取出数据赋值给R3和pc。</div><div><b>低地址取值出来放入低标号的寄存器中，高地址取值出来放入高标号的寄存器中；</b></div><div>对于上文中提到的入栈情况，效果如图：</div><div>lr寄存器中保存着原来程序的返回地址，现在将原来程序的返回地址放入pc寄存器中吗，使得其成为当前要执行指令的地址。</div><div>先将此时sp栈指针指向地址（低地址）的值（运算结果）取出放入R3寄存器（低标号）中，然后sp指针-4；</div><div>再将此时sp栈指针指向的地址（高地址）的值取出放入pc寄存器（高标号）中，然后sp指针-4；</div><div>这会pc指针指向即将执行的下一条指令的地址，即函数执行完毕，准备返回主程序继续执行。</div><h3>2.1.3 中断假设与现场保存</h3><div>假设在下图中的位置突然发生中断，<b>如何保存现场？</b></div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [8].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="587px"/><div>为了使得返回现场时，能继续工作，在我们假设的这个场景里面需要在跳转去中断的时候提前保存R2的值，不然在跳转执行的程序中可能会修改R2的值。而在其他的场景中，则需要保存不同的值。</div><div><b>现场：</b>被打断的瞬间，所有CPU内部的寄存器的值；</div><div><b>怎么保存现场：</b>保存在内存中；</div><div><b>现场保存在内存哪里：</b>保存在栈里，把16个寄存器保存在栈里，如下图；</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [9].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="279px"/><h3>2.1.4 保存现场的几种场景</h3><ul><li><div><span style="color: #FF0000;"><b>问题：是不是总是需要保存所有的寄存器</b></span></div></li><ul><li><div>对于中断来讲</div></li></ul></ul><div>对于M3/M4内核来说，对于中断来讲，有调用者保存的寄存器（硬件保存在栈里面），被调用者保存的寄存器（软件保存在栈里面）之分，只需要保存一部分寄存器的值。</div><ul><ul><li><div>对于子函数调用来讲</div></li></ul></ul><img src="【2】03四小时中度掌握FreeRTOS_files/Image [10].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="385px"/><div>对于函数的调用，有ATPCS调用规则，会利用一些寄存器（R0~R3）来进行传参，B函数在保存现场时，无需保存寄存器R0~R3；</div><ul><ul><li><div>对于任务切换来讲</div></li></ul></ul><div>但是对于任务的切换来讲，我们并不知道当前所使用的寄存器，因此还得要保存全部的寄存器。</div><h3>2.1.5 总结</h3><div>一个任务，其中必定包含一个函数，这个函数可能还会调用多个其他的函数，记录当前程序执行的状态也称之为保存现场。</div><div>可以简单的认为：一个任务就是由函数和它的栈组成，也称为运行中的函数。</div><div><b>对于一个任务，它的局部变量保存在它的栈中，它运行过程中所使用的寄存器也保存在栈里面，调用关系也保存在栈里面，如何表示这个任务，如何找到被保存的栈，所以得有一个</b><span style="color: #FF0000;"><b>任务结构体</b></span><b>。</b></div><h1>3. 创建任务函数粗略讲解</h1><h2>3.1 TCB猜测</h2><img src="【2】03四小时中度掌握FreeRTOS_files/Image [11].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>3.2 查看函数对于TCB的疑问</h2><img src="【2】03四小时中度掌握FreeRTOS_files/Image [12].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="643px"/><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>注意传参这里栈的大小这里写的1000指1000*4字节的栈大小，然后从FreeRTOS的数组中划分出来使用。</div></div><div>针对创建任务函数，需要在内存中使用TCB来保存，查看精简后TCB结构体（删除配置项）</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [13].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="752px"/><div><span style="color: #FF0000;"><b>在TCB结构体中提出如下问题</b></span></div><ul><li><div><span style="background-color: #fff199;"><b>传入的函数指针在哪，传入函数的参数在哪？</b></span></div></li></ul><div><b>在创建任务的时候，程序就修改了栈里面寄存器的值，当恢复运行的时候，pc寄存器恢复为函数地址，函数需要的参数在R0-R3寄存器中。因此在</b><span style="color: #54008B;"><b>TCB结构体中没有看到函数指针也没有看到函数参数；</b></span></div><div><b>传输的函数指针就是一个地址，函数执行的地址，要去执行这个函数，就需要将pc寄存器的值等于这个函数的地址；</b></div><div><b>传入函数的参数在小于4个时，存入R0-R3寄存器中</b></div><ul><li><div><span style="background-color: #fff199;"><b>传入的栈的大小在哪？从哪里分配？大小怎么确定；</b></span></div></li></ul><div><b>栈的大小依赖于局部变量的大小，取决于函数调用的深度（调用关系与深度）；</b></div><div><span style="color: #FF0000;"><b>在实际工作中，栈的大小只能去估计；</b></span></div><div><b>栈就是一块空闲的内存，没有人使用的，在FreeRTOS中就定义了一个巨大的数组（17KB），从中划分出一块内存作为程序运行中的栈</b></div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [14].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>3.3 TCB结构体参数理解</h2><div>该语句创建了1000*4字节大小的栈</div><div><br/></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">	xTaskCreate(vTask1, &quot;Task 1&quot;, 1000, NULL, 0, NULL);</div><div>假设刚创建的这个任务处于暂停的状态，想要其恢复现场，再次运行，就需要从栈里面恢复寄存器。</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>下图中pxStack的位置不对，位于于栈开始的低地址，在该图中形象表示在内存的最下方；</div><div>在创建任务函数中，它等于malloc后的值。</div></div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [15].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>3.4 TCB结构体中的链表参数</h2><div>TCB结构体中有两个链表</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [16].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>4.调度机制</h1><ul><li><div><b>高优先级任务先执行，高优先级任务可以抢占低优先级的任务</b></div></li><ul><li><div>高优先级的任务不停止，低优先级的任务永远无法执行；</div></li><li><div>相同优先级的任务可以轮流执行；</div></li></ul><li><div><b>任务有不止有优先级的不同，还有状态的不同，以下四种状态</b></div></li><ul><li><div><b>运行态：</b>Running</div></li><li><div><b>就绪态：</b>ready</div></li><li><div><b>阻塞态：</b>blocked，等待某件事（时间、事件）</div></li><li><div><b>暂停态：</b>suspend，休息（只有被动唤醒才会继续进入工作）</div></li></ul></ul><h2><b>4.1任务的管理</b></h2><h3><b>4.1.1怎么取出要运行的任务？</b></h3><ul><ul><ul><li><div>对于阻塞和暂停状态的任务先不用管，这里只用取出就绪和运行状态的任务，取出高优先级的任务，运行即可</div></li><li><div>如果任务优先级相同，则根据链表轮流执行，前面的先运行，运行一个Tick后，到链表尾部排队</div></li><li><div><b>函数实现</b></div></li></ul></ul></ul><div>在xTaskCreate函数中有这样的一行代码，将TCB放入就绪链表中</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [17].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>在tasks.c任务中跟踪查看TCB插入链表的函数</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [18].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>这里将就绪的TCB放入一个就绪链表的数组，这个数组大小为5，分别用于放入不同优先级的任务。此外还有阻塞链表和暂停链表。</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [19].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>回顾本文开头内容，依次创建三个任务123，任务1和2 的优先级为0，3的优先级为2，三个任务分别放入如下的链表。</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [20].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="711px"/><div>调度就只负责就绪链表，从上往下按照优先级高低对任务执行，执行完毕后讲任务放到链表尾部。</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div><b>注意事项：在就绪链表中，还有一个空闲函数。</b></div></div><h3>4.1.2 就绪链表谁来调度？</h3><div><b>问题：谁来链表取出任务执行？谁将同优先级的任务执行后放到链表尾部？</b></div><div><b>答案：</b><span style="color: #FF0000;"><b>tick中断</b></span></div><div>系统会设置定时器中断，每隔一定的计数值tickCount就会产生中断，产生中断后会调用Tic中断服务函数</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [21].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>4.1.3 状态切换的过程</h3><div>以任务3为例，这里调用vTaskDelay函数延时了5ms，此时调度器就会将任务3从pxReadyTasksList链表中移动到pxDelayTaskList链表中，所以只有就绪链表中的任务会消耗CPU资源，其他链表中的任务并不消耗CPU资源；</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [22].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="371px"/><div><span style="color: #FF0000;"><b>问题：如何判断再5ms之后再次运行？</b></span></div><div><b>答案：</b>在任务3休眠5毫秒的时候，此时RTOS也是5个tick，每个Tick中断都会检查这些链表中的任务延时是否达到，发现时间到之后，会将其从vTaskDelayList链表中移动到相应优先级的vTasksReadyList链表，然后开始调度，即从上往下的按照优先级搜索就绪链表开始执行任务。</div><h2>4.2 同优先级任务执行顺序（注意）</h2><div>空闲任务的优先级为0，并且就绪链表中优先级为0的链表中有其他任务时，空闲任务先执行，然后判断得出发生礼让，进行调度，然后重新运行。</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [23].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="501px"/><img src="【2】03四小时中度掌握FreeRTOS_files/Image [24].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="627px"/><h3>4.2.1 在相同优先级的时候，第一次执行时后创建的任务先执行</h3><div>在创建任务函数添加就绪链表的函数中，有这样一个判断，如果当前新添加的TCB优先级等于当前的TCB，那么当前的TCB就等于新添加的TCB，即当前运行的任务就是最后添加的任务。</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [25].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>4.3空闲任务——启动调度器vTaskStartScheduler()</h2><div>在程序执行启动调度器函数vTaskStartScheduler时，在函数中，会根据用户静态创建任务与动态创建任务的区别，创建一个空闲任务Idle任务，这个任务的优先级为0，放入就绪链表0。</div><div><b>空闲任务的作用：</b>通常完成一些清理工作，如果其他任务自杀，那么空闲任务就需要去释放其他任务的栈，避免内存溢出。</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [26].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>5.空闲任务礼让</h1><div><span style="color: #FF0000;"><b>如果有同是优先级0的其他就绪任务，空闲任务主动放弃一次运行机会，下一次再正常运行，因此在优先级都为0的时候，空闲任务只执行了一小会，判断得出需要礼让，就调用taskYIELD函数进行重新调度。</b></span></div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [27].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>6. 问题汇总</h1><h2>6.1 汇编文件的栈和任务的栈有什么区别</h2><ul><li><div>首先去STM32F103x.s看看汇编文件的栈，在向量表的开头指定了一个栈，在文件开头指定了一个16进制的200字节空间，空间的高地址放入了__initial_sp，在STM32启动的时候，他会将__initial_sp的数值放入sp寄存器，STM32有两个sp寄存器（main_sp/process_sp），这里放入main_sp.</div></li></ul><img src="【2】03四小时中度掌握FreeRTOS_files/Image [28].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>单片机上电复位的时候会执行Reset_Handler函数，函数会跳转到__main函数，然后跳转到main函数，main函数所用到的栈是汇编中设置的msp，也给中断函数使用</div><img src="【2】03四小时中度掌握FreeRTOS_files/Image [29].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>任务的栈是任务自己的，和main函数不一样。 </div></li></ul><h2>6.2 任务会在Tick中断前放弃运行的情况</h2><img src="【2】03四小时中度掌握FreeRTOS_files/Image [30].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>主动放弃（主动放弃会触发一次调度）</div></li><ul><li><div>vTaskDelay</div></li><li><div>xQueueResume</div></li></ul><li><div>被动放弃</div></li><ul><li><div>例如GPIO产生一个中断，xQueueSend，唤醒一个高优先级的任务4，这会会直接打断任务1的运行。</div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 