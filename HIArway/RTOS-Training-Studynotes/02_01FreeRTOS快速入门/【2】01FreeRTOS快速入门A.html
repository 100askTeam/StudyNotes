<html>
<head>
  <title>【2】01FreeRTOS快速入门A</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605138 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <meta name="content-class" content="yinxiang.superNote"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="3582"/>
<h1>【2】01FreeRTOS快速入门A</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2022/3/7 11:01</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/5/31 18:06</i></td></tr>
<tr><td><b>作者：</b></td><td><i>gi51wa2j</i></td></tr>
<tr><td><b>标签：</b></td><td><i>bingo, FreeRTOS快速入门, RTOS训练营, 正文</i></td></tr>
</table>
</div>
<br/>

<div><span><h1>1.单片机、RTOS架构的概念</h1><h2>1.1 RTOS的概念</h2><h3>1.1.1 用人来类比单片机程序和RTOS</h3><img src="【2】01FreeRTOS快速入门A_files/01_mother_do_jobs.png" type="image/png" data-filename="01_mother_do_jobs.png" style="--en-uploadstate:uploaded;"/><p style="text-align:start;">妈妈要一边给小孩喂饭，一边加班跟同事微信交流，怎么办？</p><h5 style="text-align:start;">1.1.1.1 我无法一心多用</h5><p style="text-align:start;">对于单线条的人，不能分心、不能同时做事，她只能这样做：</p><ul><li><p>给小孩喂一口饭</p></li><li><p>瞄一眼电脑，有信息就去回复</p></li><li><p>再回来给小孩喂一口饭</p></li><li><p>如果小孩吃这口饭太慢，她回复同事的信息也就慢了，被同事催：你半天都不回我？</p></li><li><p>如果回复同事的信息要写一大堆，小孩就着急得大哭起来。</p></li></ul><p style="text-align:start;">这种做法，在软件开发上就是一般的单片机开发，没有用操作系统。</p><p style="text-align:start;"><br/></p><h5 style="text-align:start;">1.1.1.2 我可以一心多用</h5><p style="text-align:start;">对于眼明手快的人，她可以一心多用，她这样做：</p><ul><li><p>左手拿勺子，给小孩喂饭</p></li><li><p>右手敲键盘，回复同事</p></li><li><p>两不耽误，小孩“以为”妈妈在专心喂饭，同事“以为”她在专心聊天</p></li><li><p>但是脑子只有一个啊，虽然说“一心多用”，但是谁能同时思考两件事？</p></li><li><p>只是她反应快，上一秒钟在考虑夹哪个菜给小孩，下一秒钟考虑给同事回复什么信息</p></li></ul><p style="text-align:start;"><br/></p><p style="text-align:start;">这种做法，在软件开发上就是使用操作系统，在单片机里叫做使用RTOS。</p><p style="text-align:start;">RTOS的意思是：Real-time operating system，实时操作系统。</p><p style="text-align:start;">我们使用的Windows也是操作系统，被称为通用操作系统。使用Windows时，我们经常碰到程序卡死、停顿的现象，日常生活中这可以忍受。</p><p style="text-align:start;">但是在电梯系统中，你按住开门键时如果没有即刻反应，即使只是慢个1秒，也会夹住人。</p><p style="text-align:start;">在专用的电子设备中，“实时性”很重要。</p><img src="【2】01FreeRTOS快速入门A_files/Image.png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="428.34674620259284px"/><p style="text-align:start;">优先级高的先进行，优先级一样的交叉进行</p><h3>1.1.2 程序简单示例</h3><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">// 经典单片机程序
void main()
{
	while (1)
    {
        喂一口饭();
        回一个信息();
    }
}
------------------------------------------------------
// RTOS程序    
喂饭()
{
    while (1)
    {
        喂一口饭();
    }
}

回信息()
{
    while (1)
    {
        回一个信息();
    }
}

void main()
{
    create_task(喂饭);
    create_task(回信息);
    start_scheduler();
    while (1)
    {
        sleep();
    }
}</div><img src="【2】01FreeRTOS快速入门A_files/02_program_with_rtos.png" type="image/png" data-filename="02_program_with_rtos.png" style="--en-uploadstate:uploaded;"/><div><br/></div><h2>1.2 架构的概念</h2><h3>1.2.1 用人来类比电子产品</h3><img src="【2】01FreeRTOS快速入门A_files/03_human_and_soc.png" type="image/png" data-filename="03_human_and_soc.png" style="--en-uploadstate:uploaded;"/><p style="text-align:start;"><br/></p><p style="text-align:start;">在电子系统中，CPU就是大脑，CPU有很多种类别，被称为架构。</p><p style="text-align:start;">常见的有：</p><ul><li><p>ARM： 目前主流的架构，用得最广，芯片公司需要付费购买，再搭配各种模块才能设计出芯片。 目前华为被美国制裁，无法获得最新的ARM架构； 对于其他公司，购买ARM新架构的价格也不低。</p></li><li><p>RISC-V： 后起之秀，开源、免费。 目前华为海思的HI3861、乐鑫的ESP32-C3等芯片，都是使用RISC-V的单片机芯片； 平头哥和全志的D1芯片，是使用RISC-V的、能运行Linux的芯片； RISC-V作为全新的架构，没有历史包袱，设计优美，在技术上大有可为，另外它开源无需授权，能摆脱技术的卡脖子问题。</p></li></ul><h3>1.2.2 要深入理解RTOS就必须深入理解CPU架构</h3><p style="text-align:start;">如果只是使用别人移植好的RTOS来写程序，当然不需要了解CPU架构。</p><p style="text-align:start;">甚至编写驱动程序时，也不需要了解CPU架构：因为我们操作的是CPU之外的设备，不是操作CPU。</p><p style="text-align:start;">但是，如果你想达到如下目标，就需要先了解CPU架构：</p><ul><li><p>深入理解RTOS的内部实现</p></li><li><p>移植RTOS</p></li><li><p>解决疑难问题</p></li></ul><h2>1.2 主要内容</h2><img src="【2】01FreeRTOS快速入门A_files/Image [1].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>FreeRTOS优势在于只实现了基本的内核功能，在很多嵌入式系统中，我们只需要多任务并不需要文件管理系统，所以选择这款系统</div></li><li><div>RT-Thread，组件非常丰富，生态完善 ，国产系统</div></li></ul><h2>1.3 官方手册</h2><div>官网：</div><div><a href="https://www.freertos.org" rev="en_rl_none">https://www.freertos.org/</a></div><div>API查询：</div><div><a href="https://www.freertos.org/a00127.html" rev="en_rl_none">https://www.freertos.org/a00127.html</a></div><h1>2.堆和栈</h1><h2>2.1 堆</h2><div>一块空闲的内存，用的时候从里面取出，不用的时候再释放回去</div><h3>2.1.1 搭建一个简单的molloc函数</h3><div>如下就是一块空闲的内存，当我们在这块空闲的内存上进行分配时，这块内存就被称之为堆</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">char heap_buf[1024];</div><img src="【2】01FreeRTOS快速入门A_files/Image [2].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="512px"/><div>这样简单的malloc函数无法实现free函数的操作</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">char heap_buf[1024];
int pos = 0;

void *my_malloc(int size)
{
	int old_pos = pos;//保存内存起始地址
	pos += size;   //记录新的内存起始地址
	return &amp;heap_buf[old_pos];//返回已经分配好空闲的地址区域
}


void my_free(void *buf)
{
	/* err */
}</div><h3>2.1.2 堆的调试</h3><div>内存分配结束后，成功获得起始地址</div><img src="【2】01FreeRTOS快速入门A_files/Image [3].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>在这里循环执行几次，查看内存</div><img src="【2】01FreeRTOS快速入门A_files/Image [4].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>在内存中查看</div><img src="【2】01FreeRTOS快速入门A_files/Image [5].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="517.0105263157895px"/><div>每执行一句，在内存监视器中看到相应的内存中会赋值我们的数字</div><img src="【2】01FreeRTOS快速入门A_files/Image [6].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><h2>2.2 栈</h2><h3>2.2.1 搭建函数多重调用模型</h3><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">
void c_fun(void)
{
}

void b_fun(void)
{
}

int a_fun(int val)
{
	int a = 8;
	a += val;
  
	b_fun();
	c_fun();
  
	return a;
}


int main(void)
{
	a_fun(46);
	
	return 0;
}</div><h3>2.2.2 问题——返回地址保存在哪里</h3><ul><li><div>main函数怎么调用a函数</div></li></ul><div>main函数调用函数a之前，会先保存a函数后下一条指令的地址放在LR寄存器中，然后才会调用函数a</div><img src="【2】01FreeRTOS快速入门A_files/Image [7].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>函数a调用函数b</div></li></ul><img src="【2】01FreeRTOS快速入门A_files/Image [8].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="584px"/><div>为防止出现LR寄存器被覆盖的情况，所以函数内部会把LR寄存器的值保存到栈中</div><div>即问题答案为：<b>返回地址保存在栈中</b></div><h3>2.2.3 使用栈的过程</h3><ul><li><div>C函数开头：</div></li></ul><ol><li><div>划分栈（用来保存LR寄存器、、、局部变量）的空间</div></li><li><div>保存例如LR寄存器的数值、局部变量数值到栈中</div></li><li><div>执行代码</div></li></ol><img src="【2】01FreeRTOS快速入门A_files/Image [9].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [10].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="259.37588176321475px"/><ul><li><div>BL main所做的事情</div></li></ul><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;"><i>BL.W是一条汇编指令：branch and link，译为跳转、保存返回地址。它保存的是下一条汇编指令的地址：</i></span></span></span></span></div><img src="【2】01FreeRTOS快速入门A_files/kv062tsd0zl4.jpg" type="image/jpeg" data-filename="kv062tsd0zl4.jpg" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [11].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="394.70302443070847px"/><ul><li><div>调用函数a</div></li></ul><img src="【2】01FreeRTOS快速入门A_files/Image [12].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="339.7083333333333px"/><ul><li><div>调用函数b</div></li></ul><img src="【2】01FreeRTOS快速入门A_files/Image [13].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="352px"/><img src="【2】01FreeRTOS快速入门A_files/Image [14].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>2.3 对于RTOS的任务栈</h2><div>每个任务都有不同的栈</div><img src="【2】01FreeRTOS快速入门A_files/Image [15].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="444px"/><h2>2.4 什么是任务？</h2><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">我们先来举几个反例。</span></span></span></span></div><ul><li><div><span style="font-size: 14px;"><span style="font-family: PingFangSC, Microsoft Yahei, Helvetica, Tahoma, Arial, Hiragino Sans GB, Hiragino Sans GB W3, STXihei, STHeiti, Heiti, SimSun, sans-serif;"><span style="color: rgb(53, 53, 53);"><span style="font-weight: 400;">任务是函数</span></span></span></span></div></li></ul><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">这肯定是不对的，或者说不是完全准确的。如果说任务是函数，那么下面这段代码：</span></span></span></span></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">voidTask1Function(void*param)
{
   while(1)
   {
       printf(&quot;1&quot;);
   }
}</div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">这是一个任务吗？其实不能这么说，它是任务的一个函数，是任务的一部分，但不是任务。如果一个函数就等于任务的话，这个函数，保存在flash中，在我们切换任务的时候并不需要保存它(对于任务而言，我们是可以对它进行创建、删除、切换等操作的)；既然它都已经保存在Flash中了，我还创建或者删除它干什么呢？</span></span></span></span></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;">所以函数是任务的一部分，不是任务的全部。</span></span></span></span></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">那么任务到底是什么呢？我们可以这样认为：任务就是一个运行着的函数。我们来看一段代码来理解这句话：</span></span></span></span></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">voidadd_val(int*pa,int*pb)
{
   
volatileinttmp;
   tmp=*pa;
   *pa=tmp+*pb;
}

voidTaskFunction(void*param)
{
   inta=1;
   intb=2;
   
   add_val(&amp;a,&amp;b);
}</div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">我们说任务是一个运行的函数，它运行的时候需要：</span></span></span></span></div><ul><li><div><span style="font-size: 14px;"><span style="font-family: PingFangSC, Microsoft Yahei, Helvetica, Tahoma, Arial, Hiragino Sans GB, Hiragino Sans GB W3, STXihei, STHeiti, Heiti, SimSun, sans-serif;"><span style="color: rgb(53, 53, 53);"><span style="font-weight: 400;">指令，也就是那些函数代码，那些函数代码需要我们自己去保存吗？不需要，只需要知道它运行到了哪里就可以；</span></span></span></span></div></li><li><div><span style="font-size: 14px;"><span style="font-family: PingFangSC, Microsoft Yahei, Helvetica, Tahoma, Arial, Hiragino Sans GB, Hiragino Sans GB W3, STXihei, STHeiti, Heiti, SimSun, sans-serif;"><span style="color: rgb(53, 53, 53);"><span style="font-weight: 400;">栈，用来保存各种寄存器、各种局部变量；</span></span></span></span></div></li></ul><h2>2.5 任务的表示</h2><div><b>一个任务有：</b></div><ul><li><div><span style="font-size: 14px;"><span style="font-family: PingFangSC, Microsoft Yahei, Helvetica, Tahoma, Arial, Hiragino Sans GB, Hiragino Sans GB W3, STXihei, STHeiti, Heiti, SimSun, sans-serif;"><span style="color: rgb(53, 53, 53);"><span style="font-weight: 400;">函数；</span></span></span></span></div></li><li><div><span style="font-size: 14px;"><span style="font-family: PingFangSC, Microsoft Yahei, Helvetica, Tahoma, Arial, Hiragino Sans GB, Hiragino Sans GB W3, STXihei, STHeiti, Heiti, SimSun, sans-serif;"><span style="color: rgb(53, 53, 53);"><span style="font-weight: 400;">地址：运行到何处；</span></span></span></span></div></li><li><div><span style="font-size: 14px;"><span style="font-family: PingFangSC, Microsoft Yahei, Helvetica, Tahoma, Arial, Hiragino Sans GB, Hiragino Sans GB W3, STXihei, STHeiti, Heiti, SimSun, sans-serif;"><span style="color: rgb(53, 53, 53);"><span style="font-weight: 400;">栈；</span></span></span></span></div></li><li><div><span style="font-size: 14px;"><span style="font-family: PingFangSC, Microsoft Yahei, Helvetica, Tahoma, Arial, Hiragino Sans GB, Hiragino Sans GB W3, STXihei, STHeiti, Heiti, SimSun, sans-serif;"><span style="color: rgb(53, 53, 53);"><span style="font-weight: 400;">寄存器的值；</span></span></span></span></div></li></ul><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">其中地址和寄存器的值都可以保存到栈里，所以我们就可以这样来表示一个任务：</span></span></span></span></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">structTask{
   // 函数指针
   // 栈的位置
};</div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">最核心的就是这样个元素。我们来看看FreeRTOS的任务相关内容：</span></span></span></span></div><table style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:1155px;" width="1155px"><colgroup><col style="width: 1155px;"></col></colgroup><tbody><tr style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; box-sizing:border-box; border-top-width:initial; border-right-width:initial; border-bottom-width:initial; border-left-width:initial; border-top-style:solid; border-right-style:solid; border-bottom-style:solid; border-left-style:solid; border-top-color:initial; border-right-color:initial; border-bottom-color:initial; border-left-color:initial; border-image-source:initial; border-image-slice:initial; border-image-width:initial; border-image-outset:initial; border-image-repeat:initial;"><th style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;text-align:center;"><img src="【2】01FreeRTOS快速入门A_files/kv062ufb0893.jpg" type="image/jpeg" data-filename="kv062ufb0893.jpg" style="--en-uploadstate:uploaded;"/></th></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><br/></div></td></tr></tbody></table><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">我们来看看这个结构体长什么样：</span></span></span></span></div><table style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:1071px;" width="1071px"><colgroup><col style="width: 1071px;"></col></colgroup><tbody><tr style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:0px; padding-right:0px; padding-bottom:0px; padding-left:0px; box-sizing:border-box; border-top-width:initial; border-right-width:initial; border-bottom-width:initial; border-left-width:initial; border-top-style:solid; border-right-style:solid; border-bottom-style:solid; border-left-style:solid; border-top-color:initial; border-right-color:initial; border-bottom-color:initial; border-left-color:initial; border-image-source:initial; border-image-slice:initial; border-image-width:initial; border-image-outset:initial; border-image-repeat:initial;"><th style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;text-align:center;"><img src="【2】01FreeRTOS快速入门A_files/kv062uj50fe9.jpg" type="image/jpeg" data-filename="kv062uj50fe9.jpg" style="--en-uploadstate:uploaded;"/></th></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><br/></div></td></tr></tbody></table><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">打叉的地方并不是必须的，因为他们都在各种宏开关里。在上图中，着重画出了表示栈的变量：栈头，栈尾；但是我们没有看到函数指针！在创建任务结构体的时候，把函数的位置保存到了栈里，所以这个机构提最核心的内容就是栈，</span><span style="font-weight: bold;">但是我们不能够认为：任务就是栈。</span><span style="font-weight: 400;">因为：</span></span></span></span></div><ul><li><div><span style="font-size: 14px;"><span style="font-family: PingFangSC, Microsoft Yahei, Helvetica, Tahoma, Arial, Hiragino Sans GB, Hiragino Sans GB W3, STXihei, STHeiti, Heiti, SimSun, sans-serif;"><span style="color: rgb(53, 53, 53);"><span style="font-weight: 400;">栈里保存有：函数的地址、寄存器的值等；</span></span></span></span></div></li><li><div><span style="font-size: 14px;"><span style="font-family: PingFangSC, Microsoft Yahei, Helvetica, Tahoma, Arial, Hiragino Sans GB, Hiragino Sans GB W3, STXihei, STHeiti, Heiti, SimSun, sans-serif;"><span style="color: rgb(53, 53, 53);"><span style="font-weight: 400;">每个任务都有自己的栈，如果任务1、任务2使用相同的栈，任务1的局部变量就会被任务2给破坏掉；</span></span></span></span></div></li></ul><h1>3. 从官方源码精简出第一个FreeRTOS程序</h1><h2>3.1 下载</h2><div>注意使用的是Github下载</div><div><a href="https://www.freertos.org" rev="en_rl_none">https://www.freertos.org/</a></div><img src="【2】01FreeRTOS快速入门A_files/Image [16].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>3.1.1 参考手册</h3><a href="【2】01FreeRTOS快速入门A_files/FreeRTOS完全开发手册之上册_快速入门.pdf"><img src="【2】01FreeRTOS快速入门A_files/51483e02b5d5d3b80a096740a1a811de.png" alt="FreeRTOS完全开发手册之上册_快速入门.pdf"></a><h2>3.2 目录结构</h2><div><b>核心文件</b></div><img src="【2】01FreeRTOS快速入门A_files/Image [17].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>3.2.1 FreeRTOS里的Demo目录命名规则</h3><div>既然是Demo，肯定要指定两项：芯片、编译器。 </div><p style="text-align:start;">所以答案之一是：芯片+编译器，比如：MCF5235_GCC。</p><p style="text-align:start;">有些目录还指定了指令集，比如：CORTEX_STM32F103_Keil  。</p><h3>3.2.2 FreeRTOS里portable目录命名规则</h3><div>移植FreeRTOS时，不同的编译器使用的语法稍有差别，所以必定有[编译器]目录，</div><p style="text-align:start;">在[编译器]下，存放[架构]相关的文件。</p><p style="text-align:start;">目录示例：</p><p style="text-align:start;">GCC\ARM_CA9</p><p style="text-align:start;">RVDS\ARM_CM3</p><h2>3.3 删减目录（删除不用的）</h2><div>以Keil工具下STM32F103芯片为例，它的FreeRTOS目录如下，按照如下进行删减</div><img src="【2】01FreeRTOS快速入门A_files/Image [18].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>3.3.1 删减流程</h3><img src="【2】01FreeRTOS快速入门A_files/Image [19].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [20].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [21].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [22].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [23].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>3.3.2 删减结果</h3><ul><li><div>删减前</div></li></ul><img src="【2】01FreeRTOS快速入门A_files/Image [24].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="375.6279325671794px"/><ul><li><div>删减后</div></li></ul><img src="【2】01FreeRTOS快速入门A_files/Image [25].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="400.0053779066501px"/><div><br/></div><div><br/></div><div><br/></div><h2>3.4 编译、执行</h2><div>原来的工程是使用Keil4编写的，我们需要把工程更改为Keil5</div><div>点击之后，重新打开</div><img src="【2】01FreeRTOS快速入门A_files/Image [26].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="462.70831871032715px"/><div>编译时会产生一堆错误，这很正常，因为我们之前删除了很多文件，这里慢慢修改就好了</div><h3>3.4.1 添加原先的common</h3><img src="【2】01FreeRTOS快速入门A_files/Image [27].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>打开common文件，删除一些用不到的文件</div><img src="【2】01FreeRTOS快速入门A_files/Image [28].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [29].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><h3>3.4.2 重新编译</h3><img src="【2】01FreeRTOS快速入门A_files/Image [30].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>没有问题了</div><h1>4. 修改打印功能</h1><div>默认demo中的例程需要原厂的LCD屏幕，这里我们更改为打印操作，在MDK上面仿真</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>对于大型的工程，比较适合使用Sourceinsight阅读源码</div></div><h2>4.1 任务</h2><ul><li><div>去掉无关的代码：LCD等</div></li><li><div>增加串口打印功能</div></li><ul><li><div> 初始化串口</div></li><li><div>实现fputc</div></li></ul></ul><h2>4.2 删除无关代码</h2><div>将一些我们不用到的文件先删除，如下图所示</div><img src="【2】01FreeRTOS快速入门A_files/Image [31].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="201.006993006993px"/><div>编译</div><img src="【2】01FreeRTOS快速入门A_files/Image [32].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>4.2.1 错误更改1</h3><div>逐一解决，分析缺少的函数，然后使用sourcein查找该函数</div><img src="【2】01FreeRTOS快速入门A_files/Image [33].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [34].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [35].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="440px"/><div>重新编译，不显示该错误</div><div><br/></div><h3>4.2.2 错误更改2</h3><img src="【2】01FreeRTOS快速入门A_files/Image [36].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>在sourceinsight里面的搜索该函数，并查找引用</div><img src="【2】01FreeRTOS快速入门A_files/Image [37].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>main函数中两次使用到了这个函数</div><img src="【2】01FreeRTOS快速入门A_files/Image [38].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>前往相关的文件中，删除函数，并注意删除它们额外的函数声明、别人对它的调用</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>注意：fputc这个函数删除其函数内容即可，在接下来的操作中，我们会使用它</div></div><div>保存后前往MDK重新编译，错误减少</div><h3>4.2.3 错误更改3</h3><img src="【2】01FreeRTOS快速入门A_files/Image [39].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>接下来的操作大致都差不多，主要是了解MDK和sourceinsight之间如何使用改错</div><div>直至修改至无错误，继续进行下一步</div><h2>4.3 修改serial.c文件</h2><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div><span style="color: #FF0000;"><b>因为我们需要一步一步的学习，所以我们需要先删除不用的函数，然后逐步学习</b></span></div></div><h3>4.3.1 完善串口初始化函数</h3><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">void SerialPortInit( void )
{
	unsigned long ulWantedBaud = 115200;
	USART_InitTypeDef USART_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;

	/* Enable USART1 clock */
	RCC_APB2PeriphClockCmd( RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE );	

	/* Configure USART1 Rx (PA10) as input floating */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	GPIO_Init( GPIOA, &amp;GPIO_InitStructure );
	
	/* Configure USART1 Tx (PA9) as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_Init( GPIOA, &amp;GPIO_InitStructure );

	USART_InitStructure.USART_BaudRate = ulWantedBaud;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No ;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
	USART_InitStructure.USART_Clock = USART_Clock_Disable;
	USART_InitStructure.USART_CPOL = USART_CPOL_Low;
	USART_InitStructure.USART_CPHA = USART_CPHA_2Edge;
	USART_InitStructure.USART_LastBit = USART_LastBit_Disable;
	
	USART_Init( USART1, &amp;USART_InitStructure );
	
	//USART_ITConfig( USART1, USART_IT_RXNE, ENABLE );
	
	USART_Cmd( USART1, ENABLE );		

}</div><div>之后再头文件中声明</div><h3>4.3.2 对printf进行重定向</h3><ul><li><div>开启KEIL-MDK中的Use MicroLIB选项</div></li></ul><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div><span style="background-color: #ffffff;"><span style="font-weight: 400;">此函数原本是将字符ch打印到文件指针stream所指向的文件流去的，现在我们不需要打印到文件流，而是打印到串口1。对函数进行修改</span></span></div></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">int fputc( int ch, FILE *f )
{
	USART_TypeDef* USARTx = USART1;

	while((USARTx-&gt;SR &amp; (1&lt;&lt;7)) == 0); //数据没有被发送出去，等待一会

	USARTx-&gt;DR = ch;
	
	return ch;
}</div><div>注意，需要包含头文件stdio.h，否则FILE类型未定义。勾选了Use MicroLib选项，重定向fputc()函数后，我们就可以在工程代码中使用printf()函数了，<span style="color: #FF0000;"><b>该函数不需要在头文件中声明</b></span></div><div><span style="color: #FF0000;"><b>puts输出时遇到空格就不发送了,C有三个用于输出字符串的标准库函数puts（）、fputs（）和printf（），注意区别。</b></span></div><div><br/></div><h2>4.4 修改main函数</h2><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">int main( void )
{
#ifdef DEBUG
  debug();
#endif

	prvSetupHardware();

	printf(&quot;Hello,world&quot;);

	/* Start the scheduler. */
	vTaskStartScheduler();

	return 0;
}</div><h2>4.5 仿真测试</h2><div>输出成功</div><img src="【2】01FreeRTOS快速入门A_files/Image [40].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>5. 第1个FreeRTOS程序及引申</h1><h2>5.1创建2个打印任务</h2><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">void Task1Function( void * param )
{
	while(1)
	{
		printf(&quot;1&quot;);
	}
}
void Task2Function( void * param )
{
	while(1)
	{
		printf(&quot;2&quot;);
	}
}

/*-----------------------------------------------------------*/

int main( void )
{
	TaskHandle_t xHandleTask1;

#ifdef DEBUG
  debug();
#endif

	prvSetupHardware();

	printf(&quot;Hello,world&quot;);

	xTaskCreate(Task1Function,&quot;Task1&quot;,100,NULL,1,&amp;xHandleTask1);
	xTaskCreate(Task2Function,&quot;Task2&quot;,100,NULL,1,NULL);

	/* Start the scheduler. */
	vTaskStartScheduler();

	return 0;
}</div><div><br/></div><div>使用xTaskCreate函数即可，<span style="color: #FF0000;"><b>记住RTOS属于分时运行的本质，导致看起来像任务并行。</b></span></div><h2>5.2 在Keil中无法在源文件中设置断点，怎么解决？</h2><img src="【2】01FreeRTOS快速入门A_files/Image [41].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [42].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [43].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [44].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>5.3 怎样设置Keil才能下载Flash并让程序自动运行？</h2><img src="【2】01FreeRTOS快速入门A_files/Image [45].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [46].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [47].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [48].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [49].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>5.4 怎么设置才能让程序在板子上调试？</h2><img src="【2】01FreeRTOS快速入门A_files/Image [50].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [51].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [52].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>5.5 在Keil中怎么重新使用模拟器运行代码？</h2><img src="【2】01FreeRTOS快速入门A_files/Image [53].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><p>指定DLL: DARMSTM.DLL</p><p>指定参数: -pSTM32F103ZE</p></div><img src="【2】01FreeRTOS快速入门A_files/Image [54].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>5.6FreeRTOS源码结构</h2><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>这里简要描述，详细信息查看手册</div></div><a href="【2】01FreeRTOS快速入门A_files/FreeRTOS完全开发手册之上册_快速入门.pdf"><img src="【2】01FreeRTOS快速入门A_files/51483e02b5d5d3b80a096740a1a811de.png" alt="FreeRTOS完全开发手册之上册_快速入门.pdf"></a><img src="【2】01FreeRTOS快速入门A_files/Image [55].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [56].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>5.7编程规范（FreeRTOS自身的）</h2><h3>5.7.1 数据类型</h3><img src="【2】01FreeRTOS快速入门A_files/Image [57].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>5.7.2 变量名</h3><img src="【2】01FreeRTOS快速入门A_files/Image [58].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>5.7.3 函数名</h3><img src="【2】01FreeRTOS快速入门A_files/Image [59].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>5.7.4 宏的名</h3><img src="【2】01FreeRTOS快速入门A_files/Image [60].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>6. 创建任务函数详解</h1><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>视频：<a href="https://www.100ask.net/detail/v_61289c1de4b092ac9837b180/3" rev="en_rl_none">https://www.100ask.net/detail/v_61289c1de4b092ac9837b180/3?from=term_6128b5469d408_KtUH9u&amp;type=25&amp;parent_pro_id=</a></div></div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>晚课：<a href="https://www.100ask.net/detail/i_617536b1e4b03b86217c789a/1" rev="en_rl_none">https://www.100ask.net/detail/i_617536b1e4b03b86217c789a/1?from=term_6128b5469d408_KtUH9u&amp;type=25&amp;parent_pro_id=</a></div></div><div>多使用结构体来编写代码，使用面向对象的思想，</div><div>对于每一个任务，都会使用一个TCB来进行描述，</div><ul><li><div><b>xTaskCreate函数参数</b></div></li></ul><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">    BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )</div><div>注意事项：</div><div style="padding-left:40px;"><b>最后的那个句柄只是这个结构体的一个指针罢了</b></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">typedef struct tskTaskControlBlock * TaskHandle_t;</div><img src="【2】01FreeRTOS快速入门A_files/Image [61].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [62].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>6.1 动态内存的使用</h2><div><span style="color: #FF0000;"><b>动态分配：xTaskCreate函数会自动给我们malloc出一块空间</b></span></div><ul><li><p>怎么表示任务？</p></li><ul><li><p>以面向对象的思想：任务控制块</p></li><li><p>可以动态分配</p></li></ul><li><p>多任务的核心：栈，可以动态分配</p></li></ul><h2>6.2 静态创建任务</h2><div>对应程序：06_freertos_example_createtaskstatic</div><div><span style="color: #FF0000;"><b>静态分配：使用xTaskCreateStatic函数，手动分配空闲内存区域</b></span></div><ul><li><p>事先分配好任务控制块TCB</p></li><li><p>事先提供栈</p></li></ul><img src="【2】01FreeRTOS快速入门A_files/Image [63].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [64].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>6.2.1 怎么配置FreeRTOS才能使用xTaskCreateStatic函数？</h3><img src="【2】01FreeRTOS快速入门A_files/Image [65].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [66].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>6.3 后面创建的任务先运行</h2><img src="【2】01FreeRTOS快速入门A_files/Image [67].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>后面的任务插入链表时，pxCurrentTCB执行它</div><div>创建任务时代码如下，后创建的最高优先级任务先执行：</div><img src="【2】01FreeRTOS快速入门A_files/Image [68].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><h2>6.4 任务函数实验</h2><div>对应程序：07_freertos_example_test</div><ul><li><p>优先级实验：<span style="color: #FF0000;"><b>FreeRTOS的优先级，参数越小，优先级越低，和常见的不一样</b></span></p></li><li><p>删除任务</p></li><li><p>使用同一个任务函数创建多个任务</p></li><li><p>栈大小实验</p></li></ul><h3>6.4.1 优先级实验</h3><ul><li><div>在原先代码的基础上，我们添加三个全局变量做为标志（<span style="color: #FF0000;"><b>原先的代码三个优先级相同</b></span>）</div></li></ul><img src="【2】01FreeRTOS快速入门A_files/Image [69].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [70].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>软件模拟的逻辑分析仪上面的显示如下，正常：</div><img src="【2】01FreeRTOS快速入门A_files/Image [71].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>修改任务1的优先级为2</div></li></ul><div>逻辑分析仪显示结果</div><img src="【2】01FreeRTOS快速入门A_files/Image [72].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>分析结论：</div></li></ul><div><b>高优先级任务没有执行完之前，低优先的任务压根没有办法执行</b></div><div><span style="color: #FF0000;"><b>FreeRTOS内部有这样</b></span><span style="color: #000000;"><b>一种</b></span><span style="color: #FF0000;"><b>调度机制：</b></span></div><div><span style="color: #FF0000;"><b>高优先级的任务先执行，同等优先级的任务交替执行</b></span></div><div style="--en-callout:true;"><div>同优先级后创建的任务先执行</div></div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>补充：如果ABC的优先级都为1，任务C最后创建，执行顺序如下，若优先级均为0，则执行顺序如下</div></div><img src="【2】01FreeRTOS快速入门A_files/Image [73].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><h3>6.4.2 删除任务</h3><div>删除任务使用vTaskDelete函数</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">void vTaskDelete( TaskHandle_t xTaskToDelete )</div><div><b>自杀：</b>vTaskDelete(NULL) </div><div><b>被杀：</b>别的任务执行vTaskDelete(pvTaskCode)，pvTaskCode是自己的句柄  </div><div><b>杀人：</b>执行vTaskDelete(pvTaskCode)，pvTaskCode是别的任务的句柄</div><div><br/></div><ul><li><div><b>注意1：</b></div></li></ul><img src="【2】01FreeRTOS快速入门A_files/Image [74].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><b>注意2</b></div></li></ul><div>删除静态创建的任务时，同样需要在vTaskDelete函数中填写<span style="color: #FF0000;">xTaskCreateStatic</span><span style="color: #000000;">函数的返回值，同样是一个句柄</span></div><h3>6.4.3 使用同一个任务函数创建多个任务</h3><p>创建一个通用的函数</p><img src="【2】01FreeRTOS快速入门A_files/Image [75].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>然后使用函数创建任务</div><img src="【2】01FreeRTOS快速入门A_files/Image [76].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><p>软件UART输出结果为</p><img src="【2】01FreeRTOS快速入门A_files/Image [77].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><span style="color: #FF0000;"><b>为什么同一个函数可以被两个不同的任务使用？</b></span></div></li></ul><div>因为函数的栈不一样，他们的局部变量保存在他们自己的栈中，所以互不影响。</div><h3>6.4.4 栈大小实验</h3><ul><li><div><b>问题：为什么malloc函数创建空闲内存的时候需要长度，而free释放内存的时候不需要长度</b></div></li><li><div>答案：一般来说在malloc分配的内存前面有一个结构体保存了内存的长度信息</div></li></ul><div><br/></div><img src="【2】01FreeRTOS快速入门A_files/Image [78].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="652.9293849658314px"/><div><span style="color: #FF0000;"><b>总结：在使用malloc分配函数的时候，会在内存前面创建一个头部，存放所分配内存的长度信息，而free函数的时候会查看这个头部的长度信息进行内存的释放。</b></span></div><img src="【2】01FreeRTOS快速入门A_files/Image [79].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="652px"/><div>接下来我们查看我们之前所写的代码，我们对栈的深度基本都是100*4字节。</div><img src="【2】01FreeRTOS快速入门A_files/Image [80].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>因为xTaskCreate函数会使用两次molloc函数</div><img src="【2】01FreeRTOS快速入门A_files/Image [81].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>所以各任务所使用的栈在内存中的显示如图：</div><img src="【2】01FreeRTOS快速入门A_files/Image [82].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>再需要了解的知识是，栈是由高地址向低地址的，所以，在我们所创建的函数中，如果拥有较大的局部变量，那么就会使得头部的信息被覆盖，从而导致程序错误，接下来我们举例说明：</div><div>在任务1 中创建一个很大的局部变量，使得超过其任务创建函数的栈大小</div><img src="【2】01FreeRTOS快速入门A_files/Image [83].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>运行结果显示：</div><img src="【2】01FreeRTOS快速入门A_files/Image [84].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><span style="color: #FF0000;"><b>所以，在创建任务的时候，程序的栈需要认真的考虑其大小是否满足我们的需求</b></span></div><h1>7. 问题补充</h1><h2>问：RT-Thread是如何退出任务、删除任务不参与调度的？</h2><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;"><i>答：RT-Thread可以直接返回，因为他设置了返回地址：你返回的话，系统会帮你自杀。</i></span></span></span></span></div><div><br/></div><h2>问：任务之间可以随便互杀还是有什么规则？</h2><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;"><i>答：FreeRTOS没有权限管理，可以随意互相删除。全靠程序员自己管理了，删除之后想用还得重新创建。</i></span></span></span></span></div><div><br/></div><h2>问：既然可以杀别的任务，任务可以创建任务吗？</h2><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;"><i>答：可以。</i></span></span></span></span></div><div><br/></div><h2>问：事先分配好和动态分配有啥区别呢，存储位置不一样吗？事先分配好放在bss，动态分配在堆区？</h2><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;"><i>答：这句话这样说基本没错，对于freeRTOS它就有点特别。freeRTOS是定了一个很大的数组，malloc是从这个数组里分配空间。所以：堆在数组里，堆在BSS里。</i></span></span></span></span></div><div><br/></div><h2>问：源码里定义了一个很大的数组，这个数组多大有规定吗？</h2><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;"><i>答：没有规定，不要超出你的内存范围就可以。</i></span></span></span></span></div><div><br/></div><h2>问：全局变量和静态变量保存在数据段或者BSS段吧？</h2><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;"><i>答：有初始值的全局变量、静态变量，保存在data段；没有初始值的全局变量、静态变量，保存在BSS段。</i></span></span></span></span></div><div><br/></div><h2>问：请问堆的定义不是一块空闲的内存吗，如果在data段定义一个数组来用，那么需要堆干嘛呢，是freertos的特别用处吗？</h2><div><b>答：1. 堆的定义：被管理的一块空闲内存，可以实现malloc、free函数，从这块内存里分配、释放内存；</b></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;"><i>2. 我可以用一个数组来占坑，霸占一块空闲内存，然后实现malloc、free，所以定义了数组之后，还需要堆干嘛呢？这个堆，就是这个数组，我需要这个数组占坑；</i></span></span></span></span></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;"><i>3. FreeRTOS使用数组来占坑，是一个很妙的主意，这个数组太大了，编译器会帮你报错。</i></span></span></span></span></div><div><br/></div><h2>问：任务创建  、任务函数和任务控制块， 联系和区别。</h2><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;"><i>答：创建一个任务：我们需要分配一个结构体来表示这个任务，这个结构体就是任务控制块；一个任务，总得做些什么事情吧？这就是一个函数；</i></span></span></span></span></div><div><br/></div><h2>问：freertos在数据段利用数组占空间，他自己也实现了malloc或free函数吗？</h2><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;"><i>答：实现了。</i></span></span></span></span></div><div><br/></div><h1>8. 任务状态理论讲解</h1><h2>8.1 任务状态理论讲解</h2><div>Tick中断处理函数会判断是否切换任务</div><div><br/></div><img src="【2】01FreeRTOS快速入门A_files/Image [85].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3> 8.1.1 FreeRTOS的系统节拍</h3><div>         任何操作系统都需要提供一个时钟节拍，以供系统处理诸如延时、超时等与时间相关的事件。</div><p>         时钟节拍是特定的周期性中断，这个中断可以看做是系统心跳。中断之间的时间间隔取决于不同的应用，一般是1ms – 100ms。时钟的节拍中断使得内核可以将任务延迟若干个时钟节拍，以及当任务等待事件发生时，提供等待超时等依据。时钟节拍率越快，系统的额外开销就越大。</p><p>         对于Cortex-M3内核的STM32F103和Cortex-M4内核的STM32F407以及F429，教程配套的例子都是用滴答定时器来实现系统时钟节拍的。</p><ul><ul><ul><li><p>滴答定时器Systick</p></li></ul></ul></ul><p style="padding-left:40px;"><b>SysTick定时器被捆绑在NVIC中，用于产生SysTick异常（异常号：15），滴答定时器是一个24位</b></p><p style="padding-left:40px;"><b>的递减计数器，支持中断。使用比较简单，专门用于给操作系统提供时钟节拍。</b></p><p style="padding-left:40px;"><br/></p><p style="padding-left:40px;">FreeRTOS的系统时钟节拍可以在配置文件FreeRTOSConfig.h里面设置：</p><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">#define configTICK_RATE_HZ                    ( ( TickType_t ) 1000 )</div><p style="padding-left:40px;">如上所示的宏定义配置表示系统时钟节拍是1KHz，</p><p style="padding-left:40px;text-align:center;">1/100 = 1ms</p><p style="padding-left:40px;">即1ms。</p><h3>8.1.2 中断时间tick的配置</h3><div><span style="color: #FF0000;"><b>FreeRTOS执行的时间基准是1MS，对于很多其他的RTOS，我们可以指定每个任务执行多少个Tick，但是FreeRTOS规定了基准的Tick是1MS，不能规定任务执行的时间。对于RTTheard，我们可以规定任务1执行10Tick，任务2执行1Tick，但是FreeRTOS不支持。</b></span></div><img src="【2】01FreeRTOS快速入门A_files/Image [86].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>8.1.3 xTaskGetTickCount获取当前的Tick时钟节拍数</h3><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div><span style="color: #FF0000;"><b>可以用于判断时间之类的操作</b></span></div></div><div><span style="color: #FF0000;"><b>在tasks.c文件夹中有一个函数，调用它即可获得当前系统运行的时钟节拍数</b></span></div><div>此函数用于在任务代码里面调用，如果在<b>中断服务程序里面调用的话，需要使用函数xTaskGetTickCountFromISR</b>，这两个函数切不可混用</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">TickType_t xTaskGetTickCount( void )
{
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
    }
    portTICK_TYPE_EXIT_CRITICAL();

    return xTicks;
}</div><h3>8.1.4 使用vTaskDelay时，如何延时若干毫秒？</h3><p style="text-align:start;"><span style="color: #FF0000;"><b>假设配置项configTICK_RATE_HZ等于1000，则tick周期为1ms，那么pdMS_TO_TICKS（）这个宏修饰的参数和直接输入vTaskDelay（ ）函数的参数所代表的意义是一样的。</b></span></p><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">		vTaskDelay(10);					  
		vTaskDelay(pdMS_TO_TICKS(10));   //两行代码的作用此时一模一样</div><p style="text-align:start;">想延时N毫秒，就使用vTaskDelay(N)。</p><p style="text-align:start;">有一个宏：pdMS_TO_TICKS(ms)，可以把毫秒转换为Tick数。</p><div style="--en-callout:true;"><div><b>踩坑</b>：延时函数<b>vTaskDelay</b></div></div><div>问题来了：为了方便使用FreeRTOS，我们会根据官网<a href="http://www.freertos.org/a00110.html" rev="en_rl_none">http://www.freertos.org/a00110.html</a>的资料修改<b>FreeRTOS Config.h</b> 中参数，常修改的参数就是<b>configTICK_RATE_HZ</b>，如果我们这里把他修改为其他数目呢？不是1000ms的话，那么<b>vTaskDelay（）函数</b>中的延时就不是以MS为单位了，这里容易引发问题，所以我们这里引出一个宏<b>pdMS_TO_TICKS，</b>使用这个宏来确定我所输入的参数是tick的时钟节拍数目，</div><div style="text-align:center;"><b>这算是一个编程习惯的问题</b></div><div>设置一个宏来确保自己所输入的参数正确。</div><h3>8.1.5 注意事项</h3><div>这里记的确定以下两点以使得逻辑分析仪中的时钟稳定。</div><ul><li><p>确认代码中设置时钟时用的频率</p></li><li><div>确认Options中Xtal的频率</div></li></ul><img src="【2】01FreeRTOS快速入门A_files/Image [87].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [88].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>8.2 任务状态</h2><div><span style="color: #FF0000;"><b>任务切换的基础：tick中断</b></span></div><h3>8.2.1 任务状态的分类</h3><img src="【2】01FreeRTOS快速入门A_files/Image [89].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="text-align:center;"><span style="font-size: 15pt;"><b>任务状态转换图</b></span></div><img src="【2】01FreeRTOS快速入门A_files/Image [90].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>8.3 四种任务状态</h2><h3>8.3.1 Ready就绪状态</h3><div>这个任务完全准备好了，随时可以运行：只是还轮不到它。这时，它就处于就绪态(Ready)。</div><h3>8.3.2 Blocked阻塞状态</h3><div>换句话讲就是等待事件发生然后运行</div><div><b>在阻塞状态的任务，它可以等待两种类型的事件： </b></div><ul><li><div>时间相关的事件  </div></li><ul><li><div>可以等待一段时间：我等2分钟  </div></li><li><div>也可以一直等待，直到某个绝对时间：我等到下午3点  </div></li></ul><li><div>同步事件：这事件由别的任务，或者是中断程序产生  </div></li><ul><li><div>例子1：任务A等待任务B给它发送数据  </div></li><li><div>例子2：任务A等待用户按下按键  </div></li><li><div>同步事件的来源有很多(这些概念在后面会细讲)：  </div></li><ul><li><div>队列(queue) </div></li><li><div>二进制信号量(binary semaphores) </div></li><li><div>计数信号量(counting semaphores) </div></li><li><div>互斥量(mutexes) </div></li><li><div>递归互斥量、递归锁(recursive mutexes) </div></li><li><div>事件组(event groups) </div></li><li><div>任务通知(task notifications)</div></li></ul></ul></ul><h3>8.3.3 Suspended暂停状态</h3><div>在日常生活的例子中，母亲正在电脑前跟同事沟通，母亲可以暂停：  </div><ul><li><div>好烦啊，我暂停一会 </div></li><li><div>领导说：你暂停一下 </div></li></ul><div><br/></div><div>FreeRTOS中的任务也可以进入暂停状态，唯一的方法是通过vTaskSuspend函数。函数原型如下：  </div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">void vTaskSuspend(TaskHandle_t xTaskToSuspend);</div><img src="【2】01FreeRTOS快速入门A_files/Image [91].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>8.4 FreeRTOS任务代码实现</h2><ul><li><div><span style="font-size: 0.9em;"><span style="font-family: var(--monospace);"><span style="color: rgb(53, 53, 53);"><span style="background-color: #f3f4f4;"><span style="font-weight: 400;">pxReadyTasksLists[ configMAX_PRIORITIES]</span></span></span></span></span><span style="font-size: 14px;"><span style="font-family: PingFangSC, Microsoft Yahei, Helvetica, Tahoma, Arial, Hiragino Sans GB, Hiragino Sans GB W3, STXihei, STHeiti, Heiti, SimSun, sans-serif;"><span style="color: rgb(53, 53, 53);"><span style="font-weight: 400;">：就绪任务链表，每个优先级都有一个链表</span></span></span></span></div></li><li><div><span style="font-size: 0.9em;"><span style="font-family: var(--monospace);"><span style="color: rgb(53, 53, 53);"><span style="background-color: #f3f4f4;"><span style="font-weight: 400;">xSuspendedTaskList</span></span></span></span></span><span style="font-size: 14px;"><span style="font-family: PingFangSC, Microsoft Yahei, Helvetica, Tahoma, Arial, Hiragino Sans GB, Hiragino Sans GB W3, STXihei, STHeiti, Heiti, SimSun, sans-serif;"><span style="color: rgb(53, 53, 53);"><span style="font-weight: 400;">：存放暂停状态的任务</span></span></span></span></div></li><li><div><span style="font-size: 0.9em;"><span style="font-family: var(--monospace);"><span style="color: rgb(53, 53, 53);"><span style="background-color: #f3f4f4;"><span style="font-weight: 400;">pxDelayedTaskList</span></span></span></span></span><span style="font-size: 14px;"><span style="font-family: PingFangSC, Microsoft Yahei, Helvetica, Tahoma, Arial, Hiragino Sans GB, Hiragino Sans GB W3, STXihei, STHeiti, Heiti, SimSun, sans-serif;"><span style="color: rgb(53, 53, 53);"><span style="font-weight: 400;">：存放阻塞状态的任务</span></span></span></span></div></li></ul><div><br/></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">4个状态：就绪、运行、阻塞、暂停。</span></span></span></span></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">用三个队列来表示：</span></span></span></span><b>就绪、暂停、Delay。</b></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">就绪状态、运行状态，这两种状态的任务都放在&quot;就绪队列&quot;里。</span></span></span></span></div><h3>8.4.1 xTaskCreate链表插入</h3><img src="【2】01FreeRTOS快速入门A_files/kv7oz5ab099w.jpg" type="image/jpeg" data-filename="kv7oz5ab099w.jpg" style="--en-uploadstate:uploaded;"/><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">我们去创建任务的时候，大家先看看这个调用关系。</span></span></span></span></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">他把任务放在某一个链表的尾部：</span></span></span></span></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">使用优先级，找到一个链表：</span></span></span></span><span style="font-size: 0.9em;"><span style="font-family: var(--monospace);"><span style="color: rgb(51, 51, 51);"><span style="background-color: #f3f4f4;"><span style="font-weight: 400;">pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ]</span></span></span></span></span></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">相同优先级的任务，如果他是就绪态、运行态，那么就会放在同一个链表里。</span></span></span></span></div><div><br/></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">使用</span></span></span></span><span style="font-size: 0.9em;"><span style="font-family: var(--monospace);"><span style="color: rgb(51, 51, 51);"><span style="background-color: #f3f4f4;"><span style="font-weight: 400;">listINSERT_END</span></span></span></span></span><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">函数插入链表，即插入到链表的尾部。</span></span></span></span></div><img src="【2】01FreeRTOS快速入门A_files/kv7oz5ab0lzg.jpg" type="image/jpeg" data-filename="kv7oz5ab0lzg.jpg" style="--en-uploadstate:uploaded;"/><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">我们创建了三个任务，优先级都是1，在列表中就是上面的顺序。</span></span></span></span></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">那执行的时候，为什么不是123，而是312 ？</span></span></span></span></div><div><span style="font-size: 14px;"><span style="font-family: PingFangSC, Microsoft Yahei, Helvetica, Tahoma, Arial, Hiragino Sans GB, Hiragino Sans GB W3, STXihei, STHeiti, Heiti, SimSun, sans-serif;"><span style="color: rgb(53, 53, 53);"><span style="font-weight: 400;">看看红色方框的代码，在</span></span></span></span><span style="font-size: 0.9em;"><span style="font-family: var(--monospace);"><span style="color: rgb(53, 53, 53);"><span style="background-color: #f3f4f4;"><span style="font-weight: 400;">task.c</span></span></span></span></span><span style="font-size: 14px;"><span style="font-family: PingFangSC, Microsoft Yahei, Helvetica, Tahoma, Arial, Hiragino Sans GB, Hiragino Sans GB W3, STXihei, STHeiti, Heiti, SimSun, sans-serif;"><span style="color: rgb(53, 53, 53);"><span style="font-weight: 400;">文件中：</span></span></span></span></div><img src="【2】01FreeRTOS快速入门A_files/spacer.gif" type="image/gif" data-filename="spacer.gif" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/kv7oz5ac0eft.jpg" type="image/jpeg" data-filename="kv7oz5ac0eft.jpg" style="--en-uploadstate:uploaded;"/><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">现在我们知道了：刚创建的任务，会根据他的优先级，放入某个就绪列表。</span></span></span></span></div><h3>8.4.2 就绪链表插入</h3><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">哪一个就绪链表？</span></span></span></span></div><img src="【2】01FreeRTOS快速入门A_files/kv7oz6af0m3u.jpg" type="image/jpeg" data-filename="kv7oz6af0m3u.jpg" style="--en-uploadstate:uploaded;"/><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">我们再来看看：暂停状态的任务，在哪一个链表里？</span></span></span></span></div><img src="【2】01FreeRTOS快速入门A_files/kv7oz6aq0otn.jpg" type="image/jpeg" data-filename="kv7oz6aq0otn.jpg" style="--en-uploadstate:uploaded;"/><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">可以看到，被暂停的任务，也会放入一个专属的链表</span></span></span></span><span style="font-size: 0.9em;"><span style="font-family: var(--monospace);"><span style="color: rgb(51, 51, 51);"><span style="background-color: #f3f4f4;"><span style="font-weight: 400;">xSuspendedTaskList</span></span></span></span></span></div><h3>8.4.3 阻塞链表插入</h3><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">阻塞状态的任务，又被放入什么链表？</span></span></span></span></div><img src="【2】01FreeRTOS快速入门A_files/kv7oz6cv0894.jpg" type="image/jpeg" data-filename="kv7oz6cv0894.jpg" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/kv7oz6d208pw.jpg" type="image/jpeg" data-filename="kv7oz6d208pw.jpg" style="--en-uploadstate:uploaded;"/><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">阻塞状态：可以等待一段时间，如果等待的时间设置为无限，那他就是暂停状态。</span></span></span></span></div><h1>9. 任务状态实验</h1><p style="text-align:start;">对应程序：08_freertos_example_task_status</p><h2>9.1 任务暂停/堵塞规定时间测试</h2><h3>9.1.3 测试结果</h3><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>测试方法：</div><div>任务1运行过程中通过xTaskGetTickCount()函数获取当前的系统时间计数数值，并在任务1执行ms后暂停任务3，执行20ms后恢复任务执行</div><div>任务2在运行1ms后进入阻塞状态，10ms后再运行</div><div><span style="color: #FF0000;"><b>如果想按照Tick数目而不是ms来运行的话，最好在这个函数中使用宏pdMS_TO_TICKS(ms)，可以把毫秒转换为Tick数。</b></span></div></div><img src="【2】01FreeRTOS快速入门A_files/Image [92].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [93].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>注意这里我设置的三个任务优先级都是1，所以在任务1延时后，它会处于Blocked阻塞状态，等待它前面的任务执行完毕后再开始执行。</div><img src="【2】01FreeRTOS快速入门A_files/Image [94].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="【2】01FreeRTOS快速入门A_files/Image [95].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>这里我修改了任务2的优先级为2，这里可以明显的看出差别了，任务2 在延时10ms后执行，响应速度非常快</div><img src="【2】01FreeRTOS快速入门A_files/Image [96].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><h1>10. vTaskDelay和VTaskDelayUntil函数讲解</h1><img src="【2】01FreeRTOS快速入门A_files/Image [97].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="423.6868426575254px"/><div><span style="font-size: 12pt;"><span style="color: #FF0000;">我们平时使用</span><span style="color: #000000;"><b>vTaskDelay函数</b></span><span style="color: #FF0000;">时，这个函数保证的是该任务在两次执行之间间隔的延时N，但是存在一个问题就是我们在执行这个延时函数之前，需要在任务中先执行我们的代码，而我们代码所做的事情如果执行时间不确定，那么就会出现如下的一种情况：</span></span></div><img src="【2】01FreeRTOS快速入门A_files/Image [98].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="587px"/><div><span style="color: #FF0000;">我们无法确定这个任务下次执行的时间，所以我们引入</span><span style="color: #000000;"><b>vTaskDelayUntil函数</b></span><span style="color: #FF0000;">，来确保任务每次开始的时间间隔一致，</span></div><div style="text-align:center;">即：<b>△t1 =  △t2</b></div><div>为了更加了解这两个函数，我们使用这样的测试代码</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">static int rands[] = {3, 56, 23, 5, 99};

void Task1Function(void * param)
{
	TickType_t tStart = xTaskGetTickCount();
	int i = 0;
	int j = 0;
	
	while (1)
	{
		
		task1flagrun = 1;
		task2flagrun = 0;
		task3flagrun = 0;

		for (i = 0; i &lt; rands[j]; i++)
			printf(&quot;1&quot;);

		j++;
		if (j == 5)
			j = 0;
#if 0       /********************通过这个宏开关来选择函数*********************/
		vTaskDelay(20);
#else
		vTaskDelayUntil(&amp;tStart, 20);
#endif
	}
}
/*-------------------main函数------------------------*/

int main( void )
{
		
#ifdef DEBUG
  debug();
#endif

	prvSetupHardware();

	printf(&quot;Hello, world!\r\n&quot;);

	xTaskCreate(Task1Function, &quot;Task1&quot;, 100, NULL, 2, &amp;xHandleTask1);
	xTaskCreate(Task2Function, &quot;Task2&quot;, 100, NULL, 1, NULL);
	xHandleTask3 = xTaskCreateStatic(Task3Function, &quot;Task3&quot;, 100, NULL, 1, xTask3Stack, &amp;xTask3TCB);

	/* Start the scheduler. */
	vTaskStartScheduler();

	/* Will only get here if there was not enough heap space to create the
	idle task. */
	return 0;
}</div><div><br/></div><div><span style="color: #FF0000;">接下来粗略了解这两个函数</span></div><h2> 10.1 vTaskDelay：</h2><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>这个函数有点意思，前文中我有记录踩坑，请查看8.1.4记录，这里有一个代码习惯的问题</div></div><div>至少等待指定个数的Tick Interrupt才能变为就绪状态</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">void vTaskDelay( const TickType_t xTicksToDelay ); /* xTicksToDelay: 等待多少个Tick */</div><div>函数vTaskDelay用于任务的延迟。</div><ul><li><p>参数xTicksToDelay用于设置延迟的时钟节拍个数，范围1- 0xFFFFFFFF。延迟时间的最大值在portmacro.h文件里面有定义：</p></li></ul><p style="padding-left:40px;">typedef uint32_t TickType_t;</p><p style="padding-left:40px;">#define portMAX_DELAY    ( TickType_t )0xffffffffUL</p><p style="padding-left:40px;">即延迟时间的范围是：1- 0xFFFFFFFF</p><img src="【2】01FreeRTOS快速入门A_files/Image [99].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="text-align:center;"><b>上次任务结束和下次任务开始间隔相同</b></div><h2>10.2 vTaskDelayUntil:</h2><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">
/* pxPreviousWakeTime: 上一次被唤醒的时间* xTimeIncrement: 要阻塞到(pxPreviousWakeTime + xTimeIncrement)
* 单位都是Tick Count
*/BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,const TickType_t xTimeIncrement );</div><div>函数vTaskDelayUntil用于周期性延迟。</div><ul><li><p>第1个参数，存储任务上次处于非阻塞状态时刻的变量地址。</p></li><li><p>第2个参数，周期性延迟时间。</p></li></ul><p style="padding-left:40px;">使用这个函数要注意以下问题：</p><p style="padding-left:40px;">1.    使用此函数需要在FreeRTOSConfig.h配置文件中配置如下宏定义为1</p><p style="padding-left:40px;">#define INCLUDE_vTaskDelayUntil    1</p><img src="【2】01FreeRTOS快速入门A_files/Image [100].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="text-align:center;"><b>两次任务开始时刻的间隔相同</b>△t1 =  △t2</div><h1>11. 问题补充</h1><h2>问：阻塞和挂起的任务都不消耗cpu吗？</h2><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;">答：</span><span style="font-weight: 400;">等会我们讲调度了流程时，你就会体会到：不消耗CPU。</span></span></span></span></div><h2>问： 老师，根据优先级添加任务，如果两个任务的优先级不同  是吧优先级低的插入尾部，还是随机的啊？</h2><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;">答：</span></span></span></span> <span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">任务的优先级不同，放到的链表就不一样。</span></span></span></span></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">比如任务1的优先级是1，放入链表：</span></span></span></span><span style="font-size: 0.9em;"><span style="font-family: var(--monospace);"><span style="color: rgb(51, 51, 51);"><span style="background-color: #f3f4f4;"><span style="font-weight: 400;">pxReadyTasksLists[1]</span></span></span></span></span></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">任务3的优先级是2， 放入链表：</span></span></span></span><span style="font-size: 0.9em;"><span style="font-family: var(--monospace);"><span style="color: rgb(51, 51, 51);"><span style="background-color: #f3f4f4;"><span style="font-weight: 400;">pxReadyTasksLists[2]</span></span></span></span></span></div><h2>问：xDelayedTaskList1  xDelayedTaskList2，有两个delay表？</h2><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;">答：</span><span style="font-weight: 400;">你暂且认为只有一个，确实有两个。</span></span></span></span></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">为了处理tick计数值溢出才设置了两个，在初级阶段，暂且认为有一个就可以。</span></span></span></span></div><h2>问：rtos实际开发的时候会不会也学linux关闭中断嵌套？关闭吧，降低实时性，不关闭吧，嵌套太多功能就会错误？</h2><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;">答：</span><span style="font-weight: 400;">FreeRTOS允许中断嵌套，断优先级不要设置那么多，同等优先级的中断不会嵌套。</span></span></span></span></div><div><span style="font-size: 14px;"><span style="font-family: Open Sans, Clear Sans, Helvetica Neue, Helvetica, Arial, Segoe UI Emoji, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: 400;">紧急处理的事情，优先级定的高一点；很重要的中断，优先级设置的高一点，高优先级的事情尽快处理。</span></span></span></span></div></span>
</div></body></html> 