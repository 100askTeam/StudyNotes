<html>
<head>
  <title>07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605138 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="1135"/>
<h1>07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2022/1/10 9:37</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/1/14 14:01</i></td></tr>
<tr><td><b>作者：</b></td><td><i>gi51wa2j</i></td></tr>
<tr><td><b>标签：</b></td><td><i>100ask_IMX6ULL_v11, bingo, 操作, 正文</i></td></tr>
</table>
</div>
<br/>

<div><span><h1>一、源文件</h1><h2>1.1 程序目的/效果</h2><div><span style="color: #FF0000;"><b>      在改变CPU频率之前，我们首先切换到其它时钟信号（示例中选择晶体振荡电路XTALOSC24M的输出），修改ARM_PLL设置并稳定在新的频率之后，再切换回ARM_PLL的输出时钟信号</b></span></div><div>    <span style="background-color: #ffff00;"><b><span style="font-weight: bold;">在main函数中，我们首先初始化并点亮led灯，设置CPU频率到81MHZ（ARM_PLL输出为648MHZ，分频参数为8），亮灯和灭灯各5次；然后设置CPU频率为648MHZ（ARM_PLL输出为1296MHZ，分频参数为2），之后无限闪灯。我们可通过肉眼观测到led的闪烁频率明显变快。</span></b></span></div><h2>1.2 文件链接</h2><a href="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/Change_CPU_Frequence.zip"><img src="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/6fd8f78fcba33e3308d1fdd61299360f.png" alt="Change_CPU_Frequence.zip"></a><div>但是感觉到源文件较为臃肿，掺杂了很多不必要的代码，尽管为以后代码的复用提供了方便，但是不利于本章节的学习。所以接下里我会对各部分内容进行裁剪，以尽量使得最少的代码完成本节的内容。</div><a href="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/改变CPU运行频率程序框架.pdf"><img src="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/e1370078d8c8b0f210e69f4418f0d449.png" alt="改变CPU运行频率程序框架.pdf"></a><h1>二、CPU时钟频率切换代码简述</h1><h2>2.1 sel_pll1_sw_clk(0);    </h2><div>作用：将ARM_ROOT时钟切换至OSC </div><div>该函数如下</div><img src="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/Image.png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>由于是时钟切换，所以我们查阅IMX6ULL芯片手册的18.5.1.5.1节Clock Switcher （648页）</div><div>该模块介绍：这个时钟切换器子模块接收<b>PLL输出时钟</b>和<b>PLL旁路时钟</b></div><div>图18-4描述了三个切换器时钟的生成（下面我只截取我们用到的图片，其余详情查看手册）</div><div>图中还包含了负责频率变换的频率切换控制子模块</div><img src="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/Image [1].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/Image [2].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>看图我们可以得知使用<b>CCSR寄存器</b>来负责控制切换器子模块，及多路复用器。</div><div>Address: 20C_4000h base + Ch offset = 20C_400Ch</div><img src="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/Image [3].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>第8位step_sel翻译：当更改ARM频率时，选择步进频率</div><div><span style="background-color: #ffff00;"><b>注意：</b></span>只有在它的输出不被使用时，这个复用器才可以被改变；换句话讲，ARM使用pll1的输出，并且step_clk没有被使用的时候，才可以更改这个复用器。（所以程序中才会先修改这个复用器，再选择使用step_sel）</div><img src="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/Image [4].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>因此，时钟切换函数思路如下：</div><ul><li><div> 使用pll1_main_clk</div></li></ul><div>需要pll1_sw_clk.设置为0</div><ul><li><div>使用osc_clk</div></li></ul><div>需要pll1_sw_clk.设置为1，需要step_sel设置为0</div><h2>2.2 set_pll(ARM_PLL, 54);</h2><div>作用：设置ARM_PLL: 24*54/2 = 648MHZ, ARM_ROOT: 648/8=81MHZ</div><div>函数（部分）截图如下</div><img src="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/Image [5].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>查阅芯片手册即可理解，该步骤将对锁相环的控制位与倍频参数一块复制给了寄存器</div><img src="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/Image [6].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>2.3 setup_arm_podf(8);     </h2><div>作用：ARM_ROOT的分频参数设置为8</div><div>函数如下：</div><img src="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/Image [7].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>这部分内容还需要了解下时钟树，查看芯片手册629页。</div><div>先看看时钟树的介绍</div><img src="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/Image [8].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="549px"/><div>     pll和pfd的默认频率值(MHz)在下面的时钟树图中显示。<span style="color: #FF0000;"><span style="background-color: #ffff00;"><b>pll和pfd控制寄存器可以根据使用的SoC的速度等级重新编程，但不应超过该速度等级的最大设置</b></span></span></div><img src="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/Image [9].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>得知使用寄存器 CACRR的位[ARM_PODF]进行分频，我们现在跳转到这个寄存器</div><div>Address: 20C_4000h base + 10h offset = 20C_4010h</div><img src="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/Image [10].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>该寄存器的0-3位负责ARM根时钟的分频，根据我们的需要设置分频参数为8</div><h2>2.4 sel_pll1_sw_clk(1);    </h2><div>作用：将ARM_ROOT切换回ARM_PLL，此时CPU工作频率为81MHZ </div><div>因为前面三步首先将时钟切换到osc_clk，然后对ARM_PLL进行设置，设置好参数后再将时钟切换回ARM_PLL。</div><h1>三、CPU切换时钟频率（文字理解）（资料）</h1><div><span style="color: #FF0000;"><b>     理解：首先查看芯片手册，寻找时钟树，查看相应寄存器，了解对应的芯片时钟体系，然后以“先倍频，再分频”的原则对CPU的频率进行更改，具体落实获取有不同，多看芯片手册总会解决。</b></span></div><div><span style="color: #FF0000;"><b>对本章不理解，可以先了解关于时钟的基础知识</b></span><a href="06 IMX6ULL裸机开发：IMX6ULL时钟体系.html"><b>06 IMX6ULL裸机开发：IMX6ULL时钟体系</b></a></div><div><br/></div><hr/><div><br/></div><div><b><span style="font-weight: bold;"> </span></b>    <b><span style="font-weight: bold;">为验证CPU频率的变化，本例使用忙等待的延时方式，控制LED灯闪烁--随着CPU频率的提升，延时时间变短，LED灯闪烁频率变快。</span></b></div><p>     正常工作时，CPU使用锁相环电路ARM_PLL的输出信号作为时钟源。<span style="color: #FF0000;">在改变CPU频率之前，我们首先切换到其它时钟信号（示例中选择晶体振荡电路XTALOSC24M的输出），修改ARM_PLL设置并稳定在新的频率之后，再切换回ARM_PLL的输出时钟信号</span>。这里我们再次引用时钟切换电路（switcher）的部分原理图，如下所示：</p><img src="07 IMX6ULL裸机开发：程序示例（改变CPU工作频率）复件_files/Image [11].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><p> </p><ul><li><p><span style="background-color: #ffff00;"><span style="font-weight: bold;">设置PLL1_SW_CLK的时钟路径</span></span></p></li></ul><p>     改变CPU频率前，pll1_sw_clk时钟路径如图中路径1所示。我们首先将其切换至路径2，待ARM_PLL（PLL1）稳定输出后，再切换回路径1。</p><p>    <span style="background-color: #ffff00;">怎么控制时钟路径？</span><span style="color: #FF0000;">修改上图中<b><span style="font-weight: bold;">用黄色标出来的寄存器值即可</span></b></span>。对应的控制函数为<span style="color: #FF0000;"><b><span style="font-weight: bold;">set_pll1_sw_clk(int sel_pll1)</span></b></span>，当参数sel_pll1值为0时，选择路径1；当参数sel_pll1值非0时，选择路径2。</p><ul><li><div><span style="background-color: #ffff00;"><b><span style="font-weight: bold;">重新设置ARM_PLL的输出频率</span></b></span></div></li></ul><p>     切换完pll1_sw_clk时钟路径之后，我们就可以重新设置ARM_PLL的输出频率，<span style="color: #FF0000;">相应的设置函数set_pll设置指定PLL的倍频参数并等待其输出频率稳定</span>。为了简化函数接口，<b><span style="font-weight: bold;">AUDIO_PLL和VIDEO_PLL的NUM（4）和DENOM（5）参数统一设置为0xF，而且不支持ENET_PLL（6）的设置</span></b>，感兴趣的同学可以自己添加相关代码。</p><ul><li><p><span style="background-color: #ffff00;"><b><span style="font-weight: bold;">设置ARM_CLK_ROOT的分频参数</span></b></span></p></li></ul><p>     时钟信号pll1_sw_clk在成为arm_clk_root送往CPU之前，还要在根时钟生成电路（root generator）经过一次分频操作，<span style="color: #FF0000;"><b><span style="font-weight: bold;">其分频参数的设置函数为setup_arm_podf，位于文件clkroot.c中</span></b>，</span></p><ul><li><p><span style="background-color: #ffff00;"><b><span style="font-weight: bold;">修改led闪烁函数</span></b></span></p></li></ul><p>     最后，为了方便比较led的闪烁频率，我们对led的接口函数稍作修改，<b><span style="font-weight: bold;">增加led_toggle函数，led的状态改变一次（从亮到灭或从灭到亮）</span></b>，这里不再展示其代码。</p><p> <span style="color: #FF0000;">   <span style="background-color: #ffff00;"><b><span style="font-weight: bold;">在main函数中，我们首先初始化并点亮led灯，设置CPU频率到81MHZ（ARM_PLL输出为648MHZ，分频参数为8），亮灯和灭灯各5次；然后设置CPU频率为648MHZ（ARM_PLL输出为1296MHZ，分频参数为2），之后无限闪灯。我们可通过肉眼观测到led的闪烁频率明显变快。</span></b></span></span></p></span>
</div></body></html> 