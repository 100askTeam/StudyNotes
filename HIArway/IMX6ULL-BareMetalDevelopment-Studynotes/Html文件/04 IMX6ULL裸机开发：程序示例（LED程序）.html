<html>
<head>
  <title>04 IMX6ULL裸机开发：程序示例（LED程序）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605138 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="701"/>
<h1>04 IMX6ULL裸机开发：程序示例（LED程序）</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2022/1/14 11:28</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/2/16 17:12</i></td></tr>
<tr><td><b>作者：</b></td><td><i>gi51wa2j</i></td></tr>
<tr><td><b>标签：</b></td><td><i>100ask_IMX6ULL_v11, bingo, 操作, 正文</i></td></tr>
</table>
</div>
<br/>

<div><span><h1>一、硬件知识-LED原理图</h1><h2>1.1 本节程序流程</h2><div>①看原理图，确定控制LED 的引脚;</div><p>②看<b>主芯片</b>的芯片手册，确定如何设置控制这个引脚;</p><p>③写程序。</p><h2>1.2 硬件知识</h2><div>方式1：使用引脚输出3.3V点亮LED，输出0V熄灭LED。</div><p>方式2：使用引脚拉低到0V点亮LED，输出3.3V熄灭LED。</p><p>方式3：使用引脚输出1.2V点亮LED，输出0V熄灭LED。（引脚驱动能力不足时使用三极管）</p><p>方式4：使用引脚输出0V点亮LED，输出1.2V熄灭LED。</p><img src="04 IMX6ULL裸机开发：程序示例（LED程序）_files/Image.png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>二、100ASK_IMX6ULL的LED程序</h1><div><b>代码</b>：</div><a href="04 IMX6ULL裸机开发：程序示例（LED程序）_files/4_led.zip"><img src="04 IMX6ULL裸机开发：程序示例（LED程序）_files/849a03b5c94883f4767652b05f7ea118.png" alt="4_led.zip"></a><div><b>原理图</b>：网盘开发板配套资料“<span style="background-color: #ffff00;">05_Hardware (原理图)/Base_board/100ask_imx6ull_v1.1.pdf</span>”。</div><h2><b>2.1 看原理图确定引脚及操作方法</b></h2><img src="04 IMX6ULL裸机开发：程序示例（LED程序）_files/Image [1].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="padding-left:80px;">从上图可知，这个 LED 用到了GPIO5_3引脚。</div><div style="padding-left:80px;">在芯片手册里，这引脚的名字是：GPIO5_IO03，可以根据名字搜到对应的寄存器。</div><div style="padding-left:80px;">当这些引脚输出低电平时，对应的LED被点亮；输出高电平时，LED熄灭。</div><h2><span style="font-size: 20px;"><span style="color: unset;"><b>2.2 所涉及的寄存器操作</b></span></span></h2><img src="04 IMX6ULL裸机开发：程序示例（LED程序）_files/Image [2].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>（CCM使能是自行添加的，此图添加使能更方便理解GPIO工作所需寄存器使用）</div><h3><span style="background-color: #ffff00;">2.2.1 使能GPIO5的时钟</span></h3><img src="04 IMX6ULL裸机开发：程序示例（LED程序）_files/Image [3].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><div style="padding-left:40px;">设置b[31:30]就可以使能GPIO5，设置为什么值呢？</div><div><span style="color: #FF0000;"><b>注意</b>：</span>在imx6ullrm.pdf中，CCM_CCGR1的b[31:30]是保留位；我以前写程序时错用了imx6ul(不是imx6ull)的手册，导致程序中额外操作了这些保留位。不去设置b[31:30]，GPIO5也是默认使能的。</div><div><br/></div><div>看下图，设置为0b11：</div><img src="04 IMX6ULL裸机开发：程序示例（LED程序）_files/Image [4].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>① 00：该GPIO模块全程被关闭</div><div>② 01：该GPIO模块在CPU run mode情况下是使能的；在WAIT或STOP模式下，关闭</div><div>③ 10：保留</div><div>④ 11：该GPIO模块全程使能</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>/* GPIO5_IO03 */</div><p>/* a. 使能GPIO5</p><p> * set CCM to enable GPIO5</p><p> * CCM_CCGR1[CG15] 0x20C406C</p><p> * bit[31:30] = 0b11</p><p> */</p></div><h3><span style="background-color: #ffff00;">2.2.2 设置GPIO5_IO03为GPIO模式</span></h3><div>设置如下寄存器：</div><img src="04 IMX6ULL裸机开发：程序示例（LED程序）_files/Image [5].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>/* b. 设置GPIO5_IO03用于GPIO</div><p> * set IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3</p><p> *      to configure GPIO5_IO03 as GPIO</p><p> * IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 0x2290014</p><p> * bit[3:0] = 0b0101 alt5</p><p> */</p></div><h3><span style="background-color: #fff199;">2.2.3 设置GPIO5_IO03为输出引脚，设置其输出电平</span></h3><div>寄存器地址为：</div><img src="04 IMX6ULL裸机开发：程序示例（LED程序）_files/Image [6].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>设置方向寄存器，把引脚设置为输出引脚：</div><img src="04 IMX6ULL裸机开发：程序示例（LED程序）_files/Image [7].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>设置数据寄存器，设置引脚的输出电平：</div><img src="04 IMX6ULL裸机开发：程序示例（LED程序）_files/Image [8].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>/* c. 设置GPIO5_IO03作为output引脚</div><p> * set GPIO5_GDIR to configure GPIO5_IO03 as output</p><p> * GPIO5_GDIR  0x020AC000 + 0x4</p><p> * bit[3] = 0b1</p><p> */</p><p> </p><p>/* d. 设置GPIO5_DR输出低电平</p><p> * set GPIO5_DR to configure GPIO5_IO03 output 0</p><p> * GPIO5_DR 0x020AC000 + 0</p><p> * bit[3] = 0b0</p><p> */</p><p> </p><p>/* e. 设置GPIO5_IO3输出高电平</p><p> * set GPIO5_DR to configure GPIO5_IO03 output 1</p><p> * GPIO5_DR 0x020AC000 + 0</p><p> * bit[3] = 0b1</p><p> */</p></div><h2>2.3 写程序</h2><p>   <span style="background-color: #fff199;">  led.c是重点，其他文件暂且不关心，比如Makefile、imx6ull.lds，这些文件的知识在后面再介绍。</span></p><div>     led_init函数会初始化LED引脚：使能、设置为GPIO模式、设置为输出引脚。</div><p>     值得关注的是第13～16行，在C语言中使用指针来访问寄存器，需要先设置指针的值，即它指向哪个地址──当然是寄存器的地址：</p><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><p>02 #include &quot;led.h&quot;</p><p>03</p><p>04 static volatile unsigned int *CCM_CCGR1                              ;</p><p>05 static volatile unsigned int *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;</p><p>06 static volatile unsigned int *GPIO5_GDIR                             ;</p><p>07 static volatile unsigned int *GPIO5_DR                               ;</p><p>08</p><p>09 void led_init(void)</p><p>10 {</p><p>11      unsigned int val;</p><p>12</p><p>13      CCM_CCGR1 = (volatile unsigned int *)(0x20C406C);</p><p>14   IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = (volatile unsigned int *)(0x2290014);</p><p>15      GPIO5_GDIR  = (volatile unsigned int *)(0x020AC000 + 0x4);</p><p>16      GPIO5_DR    = (volatile unsigned int *)(0x020AC000);</p><p>17</p><p>18      /* GPIO5_IO03 */</p><p>19      /* a. 使能GPIO5</p><p>20       * set CCM to enable GPIO5</p><p>21       * CCM_CCGR1[CG15] 0x20C406C</p><p>22       * bit[31:30] = 0b11</p><p>23       */</p><p>24      *CCM_CCGR1 |= (3&lt;&lt;30);</p><p>25</p><p>26      /* b. 设置GPIO5_IO03用于GPIO</p><p>27       * set IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3</p><p>28       *      to configure GPIO5_IO03 as GPIO</p><p>29       * IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3  0x2290014</p><p>30       * bit[3:0] = 0b0101 alt5</p><p>31       */</p><p>32      val = *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;   //临时变量</p><p>33      val &amp;= ~(0xf);                                       //清零</p><p>34      val |= (5);                                          //置位</p><p>35      *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = val;</p><p>36</p><p>37</p><p>38      /* c. 设置GPIO5_IO03作为output引脚</p><p>39       * set GPIO5_GDIR to configure GPIO5_IO03 as output</p><p>40       * GPIO5_GDIR  0x020AC000 + 0x4</p><p>41       * bit[3] = 0b1</p><p>42       */</p><p>43      *GPIO5_GDIR |= (1&lt;&lt;3);</p><p>44</p><p>45 }</p><p>46</p></div><div style="padding-left:40px;"><b>led_ctl函数会根据参数设置LED引脚的输出电平：</b></div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>47 void led_ctl(int on)</div><p>48 {</p><p>49      if (on) /* on: output 0*/</p><p>50      {</p><p>51              /* d. 设置GPIO5_DR输出低电平</p><p>52               * set GPIO5_DR to configure GPIO5_IO03 output 0</p><p>53               * GPIO5_DR 0x020AC000 + 0</p><p>54               * bit[3] = 0b0</p><p>55               */</p><p>56              *GPIO5_DR &amp;= ~(1&lt;&lt;3);</p><p>57      }</p><p>58      else  /* off: output 1*/</p><p>59      {</p><p>60              /* e. 设置GPIO5_IO3输出高电平</p><p>61               * set GPIO5_DR to configure GPIO5_IO03 output 1</p><p>62               * GPIO5_DR 0x020AC000 + 0</p><p>63               * bit[3] = 0b1</p><p>64               */</p><p>65              *GPIO5_DR |= (1&lt;&lt;3);</p><p>66      }</p><p>67 }</p></div><h2>2.4 程序的布局与运行</h2><ul><li><p>ROM上的固件根据EMMC或TF卡上1K偏移处的头部信息，把led.bin复制到0x80100000处，并运行</p></li><li><p>第一条指令把栈设置为0x80100000</p></li><li><p>程序从0x80100000向上运行，栈从0x80100000向下增长</p></li></ul><img src="04 IMX6ULL裸机开发：程序示例（LED程序）_files/Image [9].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>有疑问则去复习：</div><div><a href="02 IMX6ULL裸机开发：IMX6ULL启动流程解析.html" rev="en_rl_none">02 IMX6ULL裸机开发：IMX6ULL启动流程解析</a></div><h2><b>2.5 编译程序</b></h2><div>要编译程序，需要有交叉编译工具链。可以使用在线下载方式下载工具链，然后设置交叉编译工具链，请参考：</div><div><a href="01 IMX6ULL裸机开发：初始环境搭建.html" rev="en_rl_none">01 IMX6ULL裸机开发：初始环境搭建</a></div><div><span style="background-color: #ffff00;">然后，使用FileZilla把windows下的4_led目录上传到Ubuntu中。</span></div><div><span style="background-color: #ffff00;">最后在Ubuntu中进入4_led执行make命令即可生成led.imx、led.img</span></div><div><br/></div><div><span style="color: #9F3E30;">(注意：</span></div><div><span style="color: #9F3E30;">前文在01章节中，我们在配置交叉编译环境时，配置了永久的交叉编译环境，</span><span style="color: #A16700;">使用make命令式，要注意Makefile文件中的命令前缀，PREFIX参数是否和之前环境配置的一样，若有不同，修改即可。</span></div><div style="padding-left:40px;background-color:rgb(251, 250, 248);color:rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, Courier New, monospace;"><span style="color: rgb(51, 51, 51);">vim  ~/.bashrc</span></span></span></div><div style="padding-left:40px;background-color:rgb(251, 250, 248);color:rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, Courier New, monospace;"><span style="color: rgb(51, 51, 51);">export ARCH=arm</span></span></span><span style="color: rgb(51, 51, 51);"> export CROSS_COMPILE=arm-buildroot-linux-gnueabihf- </span><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, Courier New, monospace;"><span style="color: rgb(51, 51, 51);">export PATH=$PATH:/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin</span></span></span></div><div>最终结果跑如下：</div><img src="04 IMX6ULL裸机开发：程序示例（LED程序）_files/Image [10].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><b>注意</b>：建议在Ubuntu中目录名不要含空格，使用中文目录名是可以的。</div><div><b>注意</b>：执行make命令后会编译程序、制作映象文件，具体过程以后会详细介绍，这不是本章的内容。</div><div><b>注意</b>：如果有以下错误，执行“chmod +x tools/mkimage”后再次执行make即可：</div><img src="04 IMX6ULL裸机开发：程序示例（LED程序）_files/Image [11].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2><b>2.6上机实验</b></h2><div>参考<a href="00 IMX6ULL裸机开发：程序工具烧写整个系统或更新部分系统.html" rev="en_rl_none">00 IMX6ULL裸机开发：程序工具|烧写整个系统或更新部分系统</a></div><div><b>注意：</b>烧录时注意拨动开关是否到相应位置，USB接口是否正确链接，SD卡是否拔出</div><div><b>注意：</b>烧写、运行led程序时，串口是没有输出的，这只是一个点灯程序没用到串口。</div><div><b>注意：</b>编译下载时一定要注意虚拟机，是否虚拟机拦截了自己的下载程序。直接挂起接口</div><div><b>注意：</b>烧写到emmc时可以直接烧写imx文件，而直接烧写TF/SD卡运行时需要烧写img文件，因为硬件规定头部需要1kb的空间          </div></span>
</div></body></html> 