<html>
<head>
  <title>12 IMX6ULL裸机开发：代码重定位</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605138 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <meta name="content-class" content="yinxiang.superNote"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="1219"/>
<h1>12 IMX6ULL裸机开发：代码重定位</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2022/1/17 17:09</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/2/22 18:19</i></td></tr>
<tr><td><b>作者：</b></td><td><i>gi51wa2j</i></td></tr>
<tr><td><b>标签：</b></td><td><i>100ask_IMX6ULL_v11, bingo, 正文</i></td></tr>
</table>
</div>
<br/>

<div><span><div><br/></div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div><span style="color: #FF0000;"><b>视频教程：https://www.100ask.net/detail/p_5f857338e4b0e95a89c3cdb0/8</b></span></div><div><span style="color: #FF0000;"><b>因为imx6ull性能较强，BootRom可以自己完成重定位这一步，所以在imx6ull上理解比较不容易，本文仅用快速查阅。</b></span></div><div><span style="color: #FF0000;"><b>登陆自己微信账号查看第9章代码重定位（IMX6ULL）加深理解</b></span></div></div><div>官方参考链接：http://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html</div><div>在此之前为了方便理解，我们先对程序运行过程做一个简要阐述，  记住一个关键点</div><ul><li><div><b>链接地址：</b>Link Address是指编译器指定代码和数据<span style="color: #FF0000;">所需要</span>放置的内存地址， 由链接器配置（<span style="color: #FF0000;">但是注意链接地址是一个期望运行地址，程序并不一定从这里运行</span>）</div></li><li><div><b>加载地址：</b>Load Address是指程序被<span style="color: #FF0000;">实际</span>加载到内存的位置</div></li></ul><h1>一、概念理解</h1><h2>1.1 段的概念</h2><div>     段是程序的组成元素。将整个程序分成一个一个段，并且给每个段起一个名字，然后在链接时就可以用这个名字来指示这些段，使得这些段排布在合适的位置。</div><div>     程序分为以下几个段，在程序上电执行start.S时，程序会根据我们启动文件（start.s）中设置的代码段对代码的存放位置进行分配。</div><div style="padding-left:40px;">针对imx6ULL这款MCU，其各段的概念如下</div><table style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:760px;" width="760px"><colgroup><col style="width: 190px;"></col><col style="width: 190px;"></col><col style="width: 190px;"></col><col style="width: 190px;"></col></colgroup><tbody><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};background-color:rgb(209, 255, 85);border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;"><span style="color: null;">段名</span></div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};background-color:rgb(209, 255, 85);border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">名称</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};background-color:rgb(209, 255, 85);border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">存放的指令</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};background-color:rgb(209, 255, 85);border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">是否需要重定位</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">代码段</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">.text</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">存放代码本身，不会被修改</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">不在链接地址上就需要重定位</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">只读数据段/存放常量数据</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">.rodata</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">只读变量，一些常量字符串放在这里。可以放在ROM上，不需要复制到内存</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">不在链接地址上就需要重定位</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">数据段</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">data</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">有初值的，且非const属性的全局变量、static静态局部变量，需要从ROM复制到内存</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">如果不在链接地址上，就需要重定位</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">零初始化段</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">.bss/ZI</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><ul><li><div style="text-align:center;">初始值为0的全局变量或静态变量，没必要放在ROM上，使用前清零。</div></li><li><div style="text-align:center;">未初始化的全局变量或静态变量，没必要放在ROM上，使用之前清零就可以</div></li></ul></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">不需要重定位，因为程序里面 不保存bss段</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">注释段</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">.comment</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">存放注释</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;"><br/></div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;"> 局部变量</div></td><td colspan="3" style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;vertical-align:middle;"><div style="text-align:center;">保存在栈中，运行时生成</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div style="text-align:center;">堆</div></td><td colspan="3" style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div style="text-align:center;"><span style="background-color: #ffffff;"><span style="font-weight: 400;">一块空闲空间，使用malloc函数来管理它，malloc函数可以自己写</span></span></div></td></tr></tbody></table><h2>1.2 重定位概念（加载地址与链接地址）</h2><h3>1.2.1 什么是重定位</h3><div>保存在ROM上的全局变量的值，在使用前要复制到内存，这就是数据段重定位。</div><p>想把代码移动到其他位置，这就是代码重定位。</p><h3>1.2.2 配合下图理解代码重定位</h3><div><b>在Makefile中我们设置了加载地址</b></div><div><b>在imx6ull.lds中我们设置了链接地址</b></div><img src="12 IMX6ULL裸机开发：代码重定位_files/链接地址与加载地址.drawio.png" type="image/png" data-filename="链接地址与加载地址.drawio.png" style="--en-uploadstate:uploaded;"/><h3>1.2.3 谁来做重定位</h3><ul><li><div>程序本身：它把自己复制到链接地址去</div></li><li><div>一开始，程序可能并不位于它的链接地址上，为什么它可以执行重定位的操作？</div></li><ul><li><div> 因为重定位的代码是使用“位置无关码”写的</div></li></ul><li><p> 什么叫位置无关码：这段代码扔在任何位置都可以运行，跟它所在的位置无关</p></li><li><p>怎么写出位置无关码：</p></li><ul><li><p>跳转：使用相对跳转指令，不能使用绝对跳转指令</p></li><ul><li><p>查阅文章：<a href="evernote:///view/38694434/s14/d5674d67-4d44-4fc4-a0f6-cc856fbe5c7e/d5674d67-4d44-4fc4-a0f6-cc856fbe5c7e/" rev="en_rl_none">详解汇编语言B和LDR指令与相对跳转和绝对跳转的关系</a></p></li><li><p>只能使用branch指令(比如bl main)，不能给PC直接复制，比如ldr pc, =main</p></li></ul><li><p>不要访问全局变量、静态变量</p></li><li><p>不使用字符串</p></li></ul></ul><h3>1.2.4 重定位的实质：移动数据</h3><div>     把代码段、只读数据段、数据段，移动到它的链接地址处。</div><p>也就是<b>复制！</b></p><p>     数据复制的三要素：源、目的、长度。</p><ul><li><p>数据保存在哪里？加载地址</p></li><li><p>数据要复制到哪里？链接地址</p></li><li><p>长度</p></li></ul><p><span style="background-color: #fff199;">     这3要素怎么得到？</span></p><p>     在GCC中，使用链接脚本来描述。</p><p>     在keil中，跟链接脚本对应的是散列文件，散列的意思就是&quot;分散排列&quot;，在STM32F103这类资源紧缺的单片机芯片中：</p><ul><li><p>代码段保存在Flash上，直接在Flash上运行(当然也可以重定位到内存里)</p></li><li><p>数据段保存在Flash上，使用前被复制到内存里</p></li></ul><p>     <span style="background-color: #fff199;">但是，在资源丰富的MPU板子上：</span></p><ul><li><p>内存很大，几十M、几百M，甚至几G</p></li><li><p>可能没有XIP设备(XIP: eXecute In Place，原地执行)</p></li><ul><li><p> 没有类似STM32F103上的Flash，代码无法在存储芯片上直接运行</p></li></ul><li><p>基于这些特点，在MPU板子上</p></li><ul><li><p>代码段、数据段、BSS段等等，运行时没有必要分开存放</p></li><li><p> 重定位时，把整个程序(包括代码段、数据段等)，一起复制到它的链接地址去</p></li></ul></ul><h2>1.3 对于imx/img文件的理解</h2><img src="12 IMX6ULL裸机开发：代码重定位_files/IMX6ULL程序运行流程（代码重定位）.drawio.png" type="image/png" data-filename="IMX6ULL程序运行流程（代码重定位）.drawio.png" style="--en-uploadstate:uploaded;"/><h2>1.4 重温IMX6ULL的启动流程</h2><div><a href="02 IMX6ULL裸机开发：IMX6ULL启动流程解析.html" rev="en_rl_none">02 IMX6ULL裸机开发：IMX6ULL启动流程解析</a></div><h2>1.5 链接地址与加载地址的区别</h2><div>程序运行时，<span style="color: #FF0000;"><b>应该</b></span>位于它的链接地址处，因为：</div><ul><li><p>使用函数地址时用的是&quot;函数的链接地址&quot;，所以代码段应该位于链接地址处</p></li><li><p>去访问全局变量、静态变量时，用的是&quot;变量的链接地址&quot;，所以数据段应该位于链接地址处</p></li></ul><p><span style="color: #FF0000;"><b>但是： 程序一开始时可能并没有位于它的&quot;链接地址&quot;：</b></span></p><ul><li><p>比如对于STM32F103，程序被烧录器烧写在Flash上，这个地址称为&quot;加载地址&quot;</p></li><li><p>比如对于IMX6ULL/STM32MP157，片内ROM根据头部信息把程序读入内存，这个地址称为“加载地址”</p></li></ul><p>当加载地址 ！= 链接地址时，就需要重定位。</p><h1>二、链接脚本使用与分析</h1><div style="text-align:center;"><span style="color: #FF0000;"><b>作用：</b></span>使用链接脚本来获得各个段的信息</div><h2>2.1 链接脚本示例</h2><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">SECTIONS {
    . = 0xC0200000;       /* 对于STM32MP157设置链接地址为0xC0200000, 对于IMX6ULL设为0x80200000 */

    . = ALIGN(4);
    .text      :
    {
      *(.text)
    }

    . = ALIGN(4);
    .rodata : { *(.rodata) }

    . = ALIGN(4);
    .data : { *(.data) }

    . = ALIGN(4);
    __bss_start = .;
    .bss : { *(.bss) *(.COMMON) }
    __bss_end = .;
}</div><h2>2.2 链接脚本语法</h2><div>一个链接脚本由一个SECTION组成</div><div>一个SECTION里面，还有一个或多个section</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">SECTIONS {
...
secname start BLOCK(align) (NOLOAD) : AT ( ldadr )
  { contents } &gt;region :phdr =fill
...
  }</div><div>section是链接脚本的核心，它的语法如下：</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">secname start BLOCK(align) (NOLOAD) : AT ( ldadr )
  { contents } &gt;region :phdr =fill</div><h2>2.3 举例</h2><div>实际上不需要那么复制，不需要把语法里各项都写完。</div><h3>2.3.1 示例1</h3><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">SECTIONS { 
  .text : { *(.text) }            /* secname为&quot;.text&quot;，里面是所有文件的&quot;.text&quot;段 */ 
  .data : { *(.data) }            /* secname为&quot;.data&quot;，里面是所有文件的&quot;.data&quot;段 */
  .bss :  { *(.bss)  *(.COMMON) } /* secname为&quot;.bss&quot;，里面是所有文件的&quot;.bss&quot;段和&quot;.COMMON&quot;段 */
} </div><h3>2.3.2 示例2</h3><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">SECTIONS {
  outputa 0x10000 :     /* secname为&quot;outputa&quot;，链接地址为0x10000 */ 
    {
    first.o                 /* 把first.o整个文件放在前面 */
    second.o (.text)        /* 接下来是second.o的&quot;.text&quot;段 */
    }
  outputb :             /* secname为&quot;outputb&quot;，链接地址紧随outputa */ 
    {
    second.o (.data)        /* second.o的&quot;.data&quot;段 */
    }
  outputc :             /* secname为&quot;outputc&quot;，链接地址紧随outputb */  
    {
    *(.bss)                 /* 所有文件的&quot;.bss&quot;段 */
    *(.COMMON)              /* 所有文件的&quot;.COMMON&quot;段 */
    }
}</div><h3>2.3.3 示例3</h3><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">SECTIONS { 
  .text 0x10000 : AT (0)       /* secname为&quot;.text&quot;，链接地址是0x10000，加载地址是0 */ 
  { *(.text) }  
  .data 0x20000 : AT (0x1000)  /* secname为&quot;.data&quot;，链接地址是0x20000，加载地址是0x1000 */
  { *(.data) } 
  .bss :                       /* secname为&quot;.bss&quot;，链接地址紧随.data段，加载地址紧随.data段 */
  { *(.bss)  *(.COMMON) } 
} </div><h2>2.4 使用链接脚本获取各个段的信息</h2><div>数据复制3要素：源、目的、长度。</div><p>怎么知道某个段的加载地址、链接地址、长度？</p><h3>2.4.1 确定源</h3><div>可以用ADR伪指令获得当前代码的地址，对于这样的代码：</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">.text
.global  _start
_start: 
    ......
    adr r0, _start</div><div>adr是伪指令，它最终要转换为真实的指令。<b>它怎么获得_start代码的当前所处地址呢？</b></div><p>实际上，adr r0, _start指令的本质是r0 = pc - offset，offset是在链接时就确定了。</p><h3>2.4.2 确定目的地址</h3><div><span style="background-color: #ffffff;"><span style="font-weight: 400;">也就是怎么确定链接地址？可以用LDR伪指令。对于这样的代码：</span></span></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">.text
.global  _start
_start: 
    ......
    ldr r0, =_start</div><div>ldr是伪指令，它最终要转换为真实的指令。<b>它怎么获得_start的链接地址呢？</b></div><p>_start的链接地址在链接时，由链接脚本确定。</p><h3>2.4.3 获取更详细的信息</h3><div>在链接脚本里可以定义各类符号，在代码里读取这些符号的值。</div><p>比如对于下面的链接脚本，可以使用__bss_start、__bss_end得到BSS段的起始、结束地址：</p><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">    __bss_start = .;
    .bss : { *(.bss) *(.COMMON) }
    __bss_end = .;</div><div><span style="color: #FF0000;"><span style="background-color: #ffffff;"><b><span style="font-weight: 400;">上述代码里，有一个&quot;.&quot;，它被称为&quot;Location Counter&quot;，表示当前地址：</span></b></span></span><span style="background-color: #ffffff;"><span style="font-weight: 400;">可读可写。它表示的是链接地址。</span></span></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">. = 0xABC;       /* 设置当前地址为0xABC */ 
_abc_addr = . ;  /* 设置_abc_addr等于当前地址 */
. = . + 0x100;   /* 当前地址增加0x100 */
. = ALIGN(4);    /* 当前地址向4对齐 */</div><div>注意：&quot;Location Counter&quot;只能增大，不能较小。</div><h1>三、位置无关码</h1><div>     发现，在重定位函数copy_data执行之前，已经涉及到了片内RAM上的地址，但此时片内RAM上并没有任何程序，那为什么程序还能正常运行呢？</div><div><br/></div><div>打开反汇编文件：relocate.dis</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>07 00900000 &lt;_start&gt;:</div><p>08   900000:    e59fd00c                ldr           sp, [pc, #12]   ; 900014 &lt;halt+0x4&gt;</p><p>09   900004:    fa00016f                 blx         9005c8 &lt;copy_data&gt;</p><p>10   900008:    fb000180                blx          900612 &lt;clean_bss&gt;</p><p>11   90000c:    e59ff004                ldr           pc, [pc, #4]    ; 900018 &lt;halt+0x8&gt;</p><p>12</p><p>13 00900010 &lt;halt&gt;:</p><p>14   900010: eafffffe          b              900010 &lt;halt&gt;</p><p>15   900014: 80200000     eorhi        r0, r0, r0</p><p>16   900018: 009001b3                            ; &lt;UNDEFINED&gt; instruction: 0x009001b3</p><p>……</p><p>009001b2 &lt;main&gt;:</p></div><div>     dis文件中左边的90000xx是链接地址，表示程序运行<span style="color: #FF0000;">“<b>应该位于这里</b>”</span>。但是实际上，我们一上电，boot ROM把程序放到0x80100000去了。所以一开始运行这些指令时，它们是位于DDR里的。</div><p>     第9行的blx命令，并不是跳到0x9005c8。这要根据当前的PC值来计算，在dis里写成9005c8，这只是表示“如果程序从0x900000开始运行的话，第9行就会跳到0x9005c8”。现在程序被boot ROM复制到0x80100000，从0x80100000开始运行，我们需要根据机器码来计算出实际跳转的地址。</p><p>     blx是相对跳转指令，要跳到“pc + offset”这个地址去。程序从0x8010000运行，运行到第9行时，如下计算新地址：</p><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><p>PC=当前地址+8=0x8010004+8=0x801000C</p><p>offset=机器码“fa00016f”里的bit[23:0]*4=0x16f*4=0x5BC</p><p>新PC=PC + offset = 0x80105C8</p></div><div>     在0x80105C8这个位置，确实存有copy_data函数，所以：即使程序并不在链接地址0x900000上，它也可以运行。因为blx是相对跳转指令，它用的不是链接地址，它是<span style="color: #FF0000;">“位置无关”</span>的。使用<span style="color: #FF0000;">“位置无关码”写</span>出的代码，它可以在任何位置上运行，不一定要在“链接地址”上运行。</div><h2>3.1 上电后程序的执行</h2><ol><li><div> 程序被boot ROM重定位到0x80100000，并从这个地址开始执行第一条指令:</div></li></ol><p>此时<code style="-en-code: true">pc = 0x80100000 + 8 = 0x80100008。</code></p><ol start="2"><li><p> 执行到第2条指令“fa00016f”时，根据上述算法，它跳到地址0x80105C8去执行copy_data函数</p></li><li><p> 在执行完copy_data和clean_bss函数后，片内RAM 0x900000上已经有程序了。</p></li><li><p> 执行绝对跳转命令“<code style="-en-code: true">ldr pc, =main</code>”，它是一条伪指令，真实指令是“<code style="-en-code: true">ldr pc, [pc, #4] ; 900018 &lt;halt+0x8&gt;</code>”：</p></li></ol><p>从dis文件里很容易看出，执行完这条指令后，pc等于dis文件中“900018”上的值“009001b3”，所以程序跳到片内RAM去执行main函数了。</p><p><br/></p><div><br/></div><p><span style="color: #FF0000;"><b> </b></span>    <span style="color: #FF0000;"><b>注意：</b></span>在dis文件中，main函数的链接地址是0x009001b2，往pc寄存器里赋值0x009001b3时，bit0为1，表示main函数的代码是用Thumb指令写的。</p><p style="padding-left:40px;">那么我们应该如何写位置无关码呢？</p><p style="padding-left:40px;">答：使用相对跳转命令 b或bl，并注意</p><ul><li><p>重定位之前，不可使用绝对地址</p></li><ul><li><p>不可访问全局类变量（全局变量或static修饰的局部变量）</p></li><li><p>不可访问有初始值的数组（初始值放在rodata里，需要绝对地址来访问）</p></li></ul></ul><ul><li><p>重定位之后，使用ldr pc = xxx，跳转到绝对地址（runtime address）</p></li></ul><p> </p><div><br/></div><h1>注意</h1><div>函数指针在被赋值的时候，使用的函数的链接地址，所以没有重复定位的时候，对于程序无法运行（程序的运行与否由链接地址和加载地址之间的关系决定的）</div></span>
</div></body></html> 