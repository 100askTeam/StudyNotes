<html>
<head>
  <title>14 IMX6ULL裸机开发：异常处理（基础概念）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605138 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <meta name="content-class" content="yinxiang.superNote"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="1258"/>
<h1>14 IMX6ULL裸机开发：异常处理（基础概念）</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2022/1/19 11:04</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/3/6 14:23</i></td></tr>
<tr><td><b>作者：</b></td><td><i>gi51wa2j</i></td></tr>
<tr><td><b>标签：</b></td><td><i>100ask_IMX6ULL_v11, bingo, 正文</i></td></tr>
</table>
</div>
<br/>

<div>
<span><h1>一、ARM架构中异常与中断的处理</h1><div>重温CPU寄存器相关知识：<a href="evernote:///view/38694434/s14/aa1fcbfb-1950-47e3-b278-852a64161282/aa1fcbfb-1950-47e3-b278-852a64161282/" rev="en_rl_none">ARM处理器程序运行的过程|ARM架构简单介绍（寄存器组|RISC与CISC）</a></div><div>了解A7中断与M3/4中断的区别：<a href="evernote:///view/38694434/s14/af36b6ae-fb17-4762-be30-76d78dfcd07c/af36b6ae-fb17-4762-be30-76d78dfcd07c/" rev="en_rl_none">ARM架构中异常与中断的处理简要阐述（M3/4与A7处理器中断的区别）</a></div><h1>二、异常处理深入分析—保存现场</h1><h2>2.1 处理流程简述</h2><div>CPU每执行完一条指令都会检查有无中断/异常产生，发现有中断/异常产生，开始处理：</div><ul><li><p>保存现场</p></li><li><p>分辨异常/中断，调用对应的异常/中断处理函数</p></li><li><p>恢复现场</p></li></ul><p style="text-align:start;">对于不用的处理器，具体的处理工作有差别：</p><ul><li><p>保存现场：cortex M3/M4里是硬件完成，cortex A7等是软件实现</p></li><li><p>分辨异常/中断：cortex M3/M4里是硬件完成，cortex A7等是软件实现</p></li><li><p>调用处理函数：cortex M3/M4里是硬件来调用，cortex A7等是软件自己去调用</p></li><li><p>恢复现场：cortex M3/M4里是软件触发、硬件实现，cortex A7等是软件实现</p></li></ul><p style="text-align:start;">不管是硬件还是软件实现，第一步都是<b>保存现场</b>。</p><h2>2.2 为什么要保存现场</h2><div>举例：一个程序正常运行时过程如下图所示，但是这个程序随时会被异常打断，如何<b>保证异常处理完后，被打断的程序还可以正常运行？</b></div><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/Image.png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="542.1859931113662px"/><ul><li><p>这4条指令涉及R0、R1寄存器，程序被打断时、恢复运行时，R0、R1要保持不变</p></li><li><p>执行完第3条指令时，比较结果保存在<b>程序状态寄存器</b>里，程序被打断时、恢复运行时，程序状态寄存器保持不变</p></li><li><p>这4条指令，读取a、b内存，程序被打断时、恢复运行时，a、b内存保持不变</p></li></ul><p><br/></p><div>保存现场的目的是为了使得被中断的程序在中断恢复之后仍然可以正常运行，其中的数据无法被删改。</div><div style="padding-left:40px;"><br/></div><p style="text-align:start;">     内存保持不变，这很容易实现，程序不越界就可以。 所以，关键在于R0、R1、程序状态寄存器要保持不变(当然不止这些寄存器)：</p><ul><li><p>在处理异常前，把这些寄存器保存在栈中，这称为<b>保存现场</b></p></li><li><p>在处理完异常后，从栈中恢复这些寄存器，这称为<b>恢复现场</b></p></li></ul><hr/><h2>2.3 保存现场的过程(调用者和被调用者保存的寄存器)</h2><div>ARM处理器中有这些寄存器</div><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/003_cpu_register.png" type="image/png" data-filename="003_cpu_register.png" style="--en-uploadstate:uploaded;"/><div>在arm中有个ATPCS规则(ARM-THUMB procedure call standard（ARM-Thumb过程调用标准）。</div><div style="text-align:center;"><b>约定R0-R15寄存器的用途</b></div><ul><li><p>R0-R3</p><p>调用者和被调用者之间传参数</p></li><li><p>R4-R11</p><p>函数可能被使用，所以在函数的入口保存它们，在函数的出口恢复它们。</p></li></ul><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/004_atpcs(2).png" type="image/png" data-filename="004_atpcs(2).png" style="--en-uploadstate:uploaded;"/><div>     还有一个<b>程序状态寄存器</b>，对于M3/M4它被称为<b>XPSR</b>，对于A7它被称为<b>CPSR</b>，我们简称为PSR。 </div><div>     R0-R15、PSR，就是所谓的<b>现场</b>。</div><div>      发生异常/中断后，在处理异常/中断前，需要<b>保存现场</b>，<span style="color: #FF0000;"><b>难道需要保存所有这些寄存器吗？ </b></span></div><div>   <b>   不需要！</b> 在C函数中，可以修改R0-R3、R12、R14(LR)以及PSR。如果C函数要用到这些寄存器，就要把它们保存到栈里，在函数结束前在从栈中恢复它们。 </div><div>     这些寄存器被拆分成2部分：<b>调用者保存的寄存器(</b><span style="color: #FF0000;"><b>R0-R3,R12,LR,PSR</b></span><b>)（硬件保存）</b>、<b>被调用者保存的寄存器(</b><span style="color: #FF0000;"><b>R4-R11</b></span><b>)（软件保存）</b>。 比如函数A调用函数B，</div><div><b>对于函数A，函数A应该知道：</b></div><ul><li><p>R0-R3是用来传参数给函数B的</p></li><li><p>函数B可以肆意修改R0-R3</p></li><li><p>函数A不要指望函数B帮你保存R0-R3</p></li><li><p>保存R0-R3，是函数A的事情</p></li><li><p>对于LR、PSR也是同样的道理，保存它们是函数A的责任</p></li></ul><p style="text-align:start;"><b>对于函数B：</b></p><ul><li><p>我用到R4-R11中的某一个，我都会在函数入口保存、在函数返回前恢复</p></li><li><p>保证在B函数调用前后，函数A看到的R4-R11保存不变</p></li></ul><p style="text-align:start;"><b>假设函数B就是异常/中断处理函数，如果函数B本身能保证R4-R11不变，那么保存现场时，只需要保存这些：</b></p><ul><li><p>调用者保存的寄存器(R0-R3,R12,LR,PSR)</p></li><li><p>PC</p></li></ul><h2>2.4 对于M3/M4</h2><h3>2.4.1 硬件保存现场</h3><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/Image [1].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>2.4.2 然后调用C函数</h3><div>     C函数执行完后，它返回LR所指示的位置。难道把LR设置为被中断的程序的地址就行了吗？如果只是返回LR所指示的地方，硬件帮我们保存在栈里的寄存器，怎么恢复？</div><div><span style="color: #FF0000;"><b>     M3/M4在调用异常处理函数前，把LR设置为一个特殊的值，转给特殊的值被称为EXC_RETURN。</b></span></div><div>     当PC寄存器的值等于EXC_RETURN时，会触发异常返回机制，简单地说：会从栈里恢复R0-R3,R12,LR,PC,PSR等寄存器。EXC_RETURN的值，请参考ARM Cortex-M3与Cortex-M4权威指南.pdf，截图如下：</div><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/Image [2].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>注意：M3/M4有两个栈，主栈和进程栈，我们常常使用的是主栈</div></div><h2>2.5 对于A7</h2><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/该图片IQR寄存器有误.png" type="image/png" data-filename="该图片IQR寄存器有误.png" style="--en-uploadstate:uploaded;"/><div>     处理器有9中模式：User、Sys、FIQ、IRQ、ABT、SVC、UND、MON、HYP。 上图中深色的寄存器，表示该模式下的&quot;Banked&quot;寄存器，比如SPSR寄存器，在很多模式下都有自己的、单独的寄存器。 比如IRQ模式下访问SPSR时，访问到的是IRQ模式下自己的SPSR_irq，别的模式下无法访问SPSR_irq。</div><p style="text-align:start;">     比较值得关注的是FIQ模式，名为&quot;快中断&quot;，它有很多&quot;Banked&quot;寄存器：R8-R12,SP,LR。 在FIQ模式下，它既然能使用自己的R8-R12,SP,LR，自然不需要去保存被中断的程序的&quot;R8-R12,SP,LR&quot;了。 省去保存这几个寄存器的时间，处理中断时自然就快很多，所以被称为&quot;FIQ&quot;。</p><p style="text-align:start;">     从上图也看到，几乎每个模式下都有自己是SP寄存器，意味着这些模式下有自己的栈。</p><p style="text-align:start;"><br/></p><p style="text-align:start;">当发生异常时，以IRQ为例：</p><ul><li><p>CPU会自动切换进入对应的模式，比如进入IRQ模式</p></li><li><p>并且会把被中断是的CPSR保存到SPSR_irq里</p></li></ul><p style="text-align:start;">所以发生异常/中断时，在保存现场时，只需要保存：</p><ul><li><p>调用者保存的寄存器(R0-R3,R12,LR)</p></li><li><p>PC</p></li></ul><h1>三、CPU模式（Mode）_状态（State）与寄存器</h1><div>配合这一节笔记来查看：<a href="evernote:///view/38694434/s14/aa1fcbfb-1950-47e3-b278-852a64161282/aa1fcbfb-1950-47e3-b278-852a64161282/" rev="en_rl_none">ARM处理器程序运行的过程|ARM架构简单介绍（寄存器组|RISC与CISC）</a></div><div>主要来讲CPU的工作模式(Mode) 状态(State)寄存器，主要是cortex A7。 参考：</div><ul><li><p>《ARM体系结构与编程》作者：杜春雷</p></li><li><p>ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf</p></li><li><p>S3C2440A_UserManual_Rev13.pdf：没错，这个手册里描述得更清晰</p></li></ul><p style="text-align:start;">ARM9和cortex A7的CPU模式、状态、寄存器，以及发生异常时的处理细节，几乎是一模一样的。</p><h2>3.1CPU有9种Mode</h2><p style="text-align:start;">     跟ARM9相比，多了2中Mode：Monitor、Hyp。在文中不涉及这两种模式。 除usr模式外，其他模式是<b>特权模式</b>。 usr模式下，无法通过修改CPSR寄存器进入其他模式。 在其他模式下，可以通过修改CPSR寄存器进入其他模式。</p><ul><li><p>usr：用户模式</p></li><li><p>sys：系统模式</p></li><li><p>undefined(und)：未定义模式</p></li><li><p>Supervisor(svc)：管理模式</p></li><li><p>Monitor</p></li><li><p>Abort(abt)：中止模式 有两种情况会导致CPU今日中止模式：</p></li><ul><li><p>指令预取中止(读取某条指令时发生错误)</p></li><li><p>数据访问终止 (读写某个地址上的数据时，发生错误)</p></li></ul><li><p>Hyp</p></li><li><p>IRQ(irq)：中断模式</p></li><li><p>FIQ(fiq)：快中断模式</p></li></ul><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/005_arm_mode.png" type="image/png" data-filename="005_arm_mode.png" style="--en-uploadstate:uploaded;" width="632px"/><h2>3.2 芯片有两种State</h2><div>以前的ARM9芯片，支持两种指令集：</div><ul><li><p>ARM state：每条指令都是32位的，4个字节，高效，但是占空间</p></li><li><p>Thumb state：每天指令都是16位的，2个字节，节省空间，但是有时候效率不高</p></li></ul><p style="text-align:start;">对于Cortex A7芯片，还有Thumb2指令集，支持16位、32位指令混合编程。</p><p style="text-align:start;">这个字节数指一个汇编指令转为机器码时占据几个字节</p><h2>3.3 ARM A7寄存器介绍</h2><div>有这些寄存器：</div><ul><li><p>通用寄存器</p></li><li><p>备份寄存器(banked register)</p></li><li><p>当前程序状态寄存器(CPSR，Current Program Status Register)</p></li><li><p>CPSR的备份寄存器(SPSR，Save Program Status Register)</p></li></ul><h3>3.3.1 寄存器总图</h3><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/006_core_registers.png" type="image/png" data-filename="006_core_registers.png" style="--en-uploadstate:uploaded;"/><div>我们不关心Monitor模式、Hyp模式，那么可以看ARM9手册上的这个图，更直观：</div><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/007_core_registers_arm9.png" type="image/png" data-filename="007_core_registers_arm9.png" style="--en-uploadstate:uploaded;" width="654.787718865658px"/><h3>3.3.2 备份寄存器</h3><div><span style="background-color: #ffffff;"><span style="font-weight: 400;"> </span></span>    <span style="background-color: #ffffff;"><span style="font-weight: 400;">上图中阴影部分，是该模式下自己专有的寄存器。比如执行这样的指令</span></span></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">mov R0, R8</div><div>     在System 模式下访问的是R0和R8，在所有模式下访问R0都是同一个寄存器。但是在FIQ模式下，访问R8时访问，它对应FIQ模式专属的R8寄存器，<span style="color: #FF0000;"><b>不是同一个物理上的寄存器</b></span>，相当于：</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">mov R0,R8_fiq</div><div><b>     在这各种异常模式下，都有自己专属的R13、R14寄存器：</b></div><ul><li><p>R13用作SP(栈) ：所以发生异常时，使用的是该异常模式下的栈</p></li><li><p>R14用作LR(返回地址)：用来保存发生异常时的指令地址，处理完异常后，根据LR的值恢复被中断的程序</p></li></ul><div><b>     为什么快中断(FIQ)有那么多专属寄存器？ 回顾一下中断的处理过程：</b></div><ul><li><p>保存现场(保存被中断模式的寄存器)</p></li><li><p>处理异常</p></li><li><p>最后恢复这些寄存器</p></li></ul><p style="text-align:start;">     假设程序正在系统模式/用户模式下运行， 当发生中断时，需要把R0 ~ R14这些寄存器全部保存下来。 但如果是快中断，那么就不需要保存系统/用户模式下的R8 ~ R12这几个寄存器， 因为在FIQ模式下有自己专属的R8 ~ R12寄存器， 这样可以省略保存寄存器的时间，加快处理速度。</p><h3>3.3.3 程序状态寄存器</h3><div><span style="background-color: #ffffff;"><span style="font-weight: 400;">CPSR，表示当前程序状态寄存器，这是一个特别重要的寄存器SPSR，用来保存CPSR，它们格式如下</span></span></div><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/008_xpsr.png" type="image/png" data-filename="008_xpsr.png" style="--en-uploadstate:uploaded;"/><ul><li><div><b>M4 ~ M0 </b></div></li></ul><div style="padding-left:40px;"><span style="background-color: #ffffff;"><span style="font-weight: 400;"> </span></span>    <span style="background-color: #ffffff;"><span style="font-weight: 400;">表示当前CPU处于哪一种模式(Mode)我们可以读取这5位来判断CPU处于哪一种模式，也可以修改它进入其他模式。</span></span></div><div><b>注意：</b>假如当前处于用户模式下，是没有权限修改这些位的。M4 ~ M0对应模式，如下图所示：</div><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/009_xpsr_mode_bits.png" type="image/png" data-filename="009_xpsr_mode_bits.png" style="--en-uploadstate:uploaded;" width="261.5009671179884px"/><ul><li><div><b>其他位</b></div></li><ul><li><p>Bit5 State bits：表示CPU工作于Thumb State还是ARM State，用的指令集是什么。</p></li><li><p>Bit6 FIQ disable：当bit6等于1时，FIQ被禁止。</p></li><li><p>Bit7 IRQ disable：当bit5等于1时，禁止所有的IRQ中断，这个位是IRQ的总开关</p></li><li><p>Bite28 ~ Bit31是状态位 什么是状态位，比如说执行这两条指令</p></li></ul></ul><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">cmp R0, R1
beq xxx</div><div><br/></div><div><span style="background-color: #ffffff;"><span style="font-weight: 400;"> </span></span>    <span style="background-color: #ffffff;"><span style="font-weight: 400;">如果R0 等于 R1，第1条指令会导致CPSR中的Z位等于1。后面的跳转指令，会根据Z位的值决定是否跳转：Z等于1就跳转，否则就不跳转。 </span></span>    </div><div><span style="color: #FF0000;"><b> </b></span>    <span style="color: #FF0000;"><b>每个模式下都有自己的SPSR寄存器，表示发生异常时，这个寄存器会用来保存被中断的模式下的CPSR。就比如程序在系统模式下运行，当发生中断时会进入irq模式时，这个SPSR_irq就保存系统模式下的CPSR。</b></span></div><h2>3.4 发生异常时处理流程</h2><div>发生异常时CPU如何协同工作的</div><h3>3.4.1 异常向量表</h3><div><span style="background-color: #ffffff;"><b><span style="font-weight: 400;">在ARM9里，异常向量表基地址只有两个取值：0、0xFFFF0000。</span></b></span></div><div><span style="background-color: #ffffff;"><b><span style="font-weight: 400;">对于cortex A7，它的异常向量表基地址是可以修改的。</span></b></span></div><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/010_vector_base.png" type="image/png" data-filename="010_vector_base.png" style="--en-uploadstate:uploaded;"/><h3>3.4.2 进入异常的处理流程(硬件)</h3><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/011_exception_entry.png" type="image/png" data-filename="011_exception_entry.png" style="--en-uploadstate:uploaded;"/><div><span style="color: #FF0000;"><b>我们来翻译一下： 发生异常时，我们的CPU会做什么事情</b></span></div><ol><li><p>硬件确定要进入哪种异常模式</p></li><li><p>LR寄存器被更新，它表示处理完异常后要返回到哪里，这个值可能需要修改。</p></li><li><p>SPSR = 被中断时的CPSR</p></li><li><p>对于&quot;Security Exceptions&quot;，……，本课程不涉及</p></li><li><p>更新异常模式下的CPSR：设置模式位、设置mask bit(屏蔽其他异常)、设置指令集状态位</p></li><li><p>PC = 异常入口地址</p></li><li><p>从PC所指示地方执行程序</p></li></ol><h3>3.4.3 退出异常</h3><div><span style="background-color: #ffffff;"><span style="font-weight: 400;">在</span></span><code style="-en-code: true"><span style="background-color: #ffffff;"><span style="font-weight: 400;">ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf</span></span></code><span style="background-color: #ffffff;"><span style="font-weight: 400;">中，对异常的退出，描述得很复杂。但是很多情况，我们并不涉及。</span></span></div><div><span style="background-color: #ffffff;"><span style="font-weight: 400;">所以我们参考S3C2440A_UserManual_Rev13.pdf，它描述得更清晰、简单。</span></span></div><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/012_exception_return.png" type="image/png" data-filename="012_exception_return.png" style="--en-uploadstate:uploaded;"/><div><span style="color: #FF0000;"><b>从异常中退出，要做什么事情？</b></span></div><ol><li><p>让LR减去某个值，然后赋值给PC(PC = 某个异常LR寄存器减去 offset) </p></li></ol><p><b>     减去什么值呢？ </b></p><p style="padding-left:40px;">也就是我们怎么返回去继续执行原来的程序，根据下面这个表来取值：</p><p style="padding-left:80px;">如果发生的是SWI可以把 R14_svc复制给PC，</p><p style="padding-left:80px;">如果发生的是IRQ可以把R14_irq的值减去4赋值给PC</p><ol start="2"><li><p>把CPSR的值恢复(CPSR 值等于 某一个一场模式下的SPSR)</p></li><li><p>清中断（如果是中断的话，对于其他异常不用设置）</p></li></ol><h3>3.4.4 确定异常返回地址</h3><div><b>发生异常时，LR寄存器里保存的值是什么？</b></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;"><b>LR = Preferred return address + offset</b></div><div><b>&quot;Preferred return address&quot;是什么？</b>请看下图：</div><div>那一条导致异常的指令的地址</div><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/013_preferred_return_address.png" type="image/png" data-filename="013_preferred_return_address.png" style="--en-uploadstate:uploaded;"/><div><b>offset是什么？请看下图：</b></div><div>根据不同指令集和不同的异常选择相应的offset</div><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/014_exception_return_address.png" type="image/png" data-filename="014_exception_return_address.png" style="--en-uploadstate:uploaded;"/><div><span style="background-color: #ffffff;"><span style="font-weight: 400;">从异常中返回时，LR可能需要调整，再赋给PC。ARM9的手册讲得比较清楚，返回指令如下：</span></span></div><img src="14 IMX6ULL裸机开发：异常处理（基础概念）_files/Image [3].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><h1>四、ARM_Thumb指令集程序示例</h1><div><a href="evernote:///view/38694434/s14/0db96d36-9397-451a-bf54-43caa21129ce/0db96d36-9397-451a-bf54-43caa21129ce/" rev="en_rl_none">ARM如何告诉编译器代码所使用的指令集</a></div><h1></h1></span>
</div></body></html> 