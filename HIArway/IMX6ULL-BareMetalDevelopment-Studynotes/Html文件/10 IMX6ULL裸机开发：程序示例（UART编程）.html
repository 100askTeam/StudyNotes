<html>
<head>
  <title>10 IMX6ULL裸机开发：程序示例（UART编程）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605138 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <meta name="content-class" content="yinxiang.superNote"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="576"/>
<h1>10 IMX6ULL裸机开发：程序示例（UART编程）</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2022/1/14 13:27</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/2/11 22:41</i></td></tr>
<tr><td><b>作者：</b></td><td><i>gi51wa2j</i></td></tr>
<tr><td><b>标签：</b></td><td><i>100ask_IMX6ULL_v11, bingo, 操作, 正文</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div style="text-align:center;"><span style="color: #FF0000;"><span style="background-color: #fff199;"><b>写代码前需要先明白自己要做什么</b></span></span></div><div style="text-align:center;"><span style="color: #FF0000;"><span style="background-color: #fff199;"><b>1小时思考10分钟写代码的模式，而不是焦头烂额的什么都不懂就开始敲写代码</b></span></span></div><h1>一、串口编程步骤</h1><h2><b>1.1 看原理图确定UART引脚</b></h2><ul><li><div><span style="background-color: #fff199;">有很多串口，使用哪一个？看原理图确定</span></div></li></ul><div><b>原理图</b>：网盘开发板配套资料“05_Hardware (原理图)/Base_board/100ask_imx6ull_v1.1.pdf”。</div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image.png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div><span style="color: #FF0000;">100ASM IMX6ULL的UART1接到一个USB串口芯片，然后就可以通过USB线连接电脑了</span></div></li><li><div><span style="color: #FF0000;">上图中的USART1_RX、USART1_TX，接到了PA9、PA10</span></div></li></ul><div>从上图可知，采用的UART转USB的方案，使用的是UART1。查看IMX6ULL芯片手册《Chapter 55 Universal Asynchronous Receiver/Transmitter(UART)》中涉及关键字UART1的寄存器并设置它。</div><h2>1.2 配置引脚为UART功能</h2><ul><li><p>至少用到发送、接收引脚：txd、rxd</p></li><li><p>需要把这些引脚配置为UART功能，并使能UART模块</p></li></ul><h2>1.3 设置串口参数</h2><ul><li><p>有哪些参数？</p></li><ul><li><p>波特率</p></li><li><p>数据位</p></li><li><p>校验位</p></li><li><p>停止位</p></li></ul><li><p>示例： 比如15200,8n1表示波特率为115200,8个数据为，没有校验位，1个停止位</p></li></ul><h2>1.4 根据状态寄存器读写数据</h2><ul><li><p>肯定有一个数据寄存器，程序把数据写入，即刻通过串口向外发送数据</p></li><li><p>肯定有一个数据寄存器，程序读取这个寄存器，就可以获得先前接收到的数据</p></li><li><p>很多有状态寄存器</p></li><ul><li><p>判断数据是否发送出去？是否发送成功？</p></li><li><p>判断是否接收到了数据？</p></li></ul></ul><h1><b>二、IMX6ULL串口操作</b></h1><div><b>代码</b>：GIT下载后在“10_裸机开发/01_100ASK_IMX6ULL裸机程序/8_UART串口编程/001_uart_txd_char”目录下。</div><div>寄存器配置共分为4步骤，本小节中的代码都在程序文件uart.c中。</div><h2><span style="background-color: #ffff00;">2.1时钟操作：</span><span style="color: #FF0000;"><span style="background-color: #ffff00;">配置</span></span><span style="background-color: #ffff00;">并</span><span style="color: #FF0000;"><span style="background-color: #ffff00;">使能</span></span><span style="background-color: #ffff00;">UART1时钟|UART特殊时钟</span></h2><div>配置并使能UART1时钟，参考资料：芯片手册《Chapter 18: Clock Controller M  odule (CCM)》。</div><h3><span style="color: #FF0000;"><b>2.1.1 配置</b></span><b>UART模块的时钟（寄存器：CCM_CSCDR1）</b>：</h3><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [1].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>根据上图可知，我们需要设置<b>CCM_CSCDR1 [UART_CLK_SEL]</b>和<b>CCM_CSCDR1  [UART_CLK_PODF]。</b></div><div><span style="color: #FF0000;"><b>通过CSDR1寄存器为UART提供总时钟</b></span></div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [2].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>     由上图CCM_CSCDR1寄存器，我们可以了解到</div><div>CCM_CSCDR1 [UART_CLK_SEL]默认值为0；CCM_CSCDR1 [UART_CLK_PODF]默认值为0</div><div><br/></div><div>     我们一般选择 pll3_80m 作为 UART 的时钟源，UART_CLK_PODF分频系数选1分频（不分频），最后得到UART的时钟频率为80MHz。</div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [3].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><div>     正好默认值都为0满足我们的时钟需求，所以后续的编程实验，串口时钟这部分可以不设置，用默认值就可以了。</div><h3><span style="color: #FF0000;"><b>2.1.2 使能</b></span><b>UART模块的时钟（寄存器：CCM_CCGR5）</b></h3><div><b>上一步为UART选择了总时钟，这一步需要为UART模块提供时钟</b></div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [4].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>由上图CCM_CCGR5寄存器，我们可以了解到CCM_CCGR5[CG12] 的默认值为11。</div><div>参考章节<u>《4.2.6 CCM用于设置是否向GPIO模块提供时钟》</u>我们了解到11表示该模块全程使能，使用默认值，无需设置。</div><div>因此时钟这块我们都不需要配置，直接使用默认值即可。</div><h3>2.1.3 UART特殊时钟</h3><div>查看芯片手册上对于UART的时钟需求</div><div style="--en-callout:true;"><div>芯片手册上对于该模块时钟和特殊时钟的要求</div></div><ul><li><div>手册截图（55.4.2.1（P3571））</div></li></ul><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [5].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>重点翻译</div></li></ul><div><span style="color: #FF0000;"><b> </b></span>    <span style="color: #FF0000;"><b>注意这边使用的两个时钟</b></span></div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [6].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>其中对于FIFO，我们转去相关查看寄存器芯片手册中的描述</div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [7].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><span style="color: #FF0000;"><b>     查看2.3.3节中的寄存器描述，我们得知，这个TxFIFO和RxFIFO是默认设置好的，所以我们对module_clock进行再一次的分频参数设置，具体寄存器的设置请查看2.3.3节配置。</b></span></div><h2><span style="background-color: #ffff00;">2.2 配置引脚功能：复用相关GPIO为UART1功能</span></h2><div>     复用相关GPIO为UART1功能，参考资料：芯片手册《Chapter 32: IOMUX Controller  (IOMUXC)》。</div><div>     根据前面硬件连接讲解，我们知道串口通信精简接法需要3根信号线，其中GND已由硬件连接了，所以接下来我们需要配置剩余的两个GPIO引脚 （UART1_TXD与UART1_RXD）。</div><h3><b>2.2.1 配置UART1_TX复用功能</b></h3><div>寄存器：IOMUXC_SW_MUX_CTL_PAD_UART1_TX_DATA。</div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [8].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>     由上图我们得知IOMUXC_SW_MUX_CTL_PAD_UART1_TX_DATA[MUX_MODE]的默认值为0101，因此我们需要将其改为0，用于UART_TX功能。</div><h3><b>2.2.2 配置UART1_RX复用功能</b></h3><div>     寄存器：IOMUXC_SW_MUX_CTL_PAD_UART1_RX_DATA。</div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [9].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>     由上图我们得知IOMUXC_SW_MUX_CTL_PAD_UART1_RX_DATA[MUX_MODE]的默认值为0101，因此我们需要将其改为0，用于UART_RX功能。（程序文件：uart.c）</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">IOMUXC_SW_MUX_CTL_PAD_UART1_TX_DATA       = (volatile unsigned int  *)(0x20E0084); 
IOMUXC_SW_MUX_CTL_PAD_UART1_RX_DATA       = (volatile unsigned int  *)(0x20E0088); 
*IOMUXC_SW_MUX_CTL_PAD_UART1_RX_DATA = 0; 
*IOMUXC_SW_MUX_CTL_PAD_UART1_TX_DATA = 0;</div><div style="--en-callout:true;"><div>设置“Daisy Chain select”</div></div><div style="padding-left:40px;"><span style="color: #FF0000;"><b>着重提醒</b>：IMX6ULL特殊的地方，IMX6ULL中，可能会有多个引脚都可以驱动某个模块，还需要进一步选择。</span></div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div style="padding-left:40px;">查看芯片手册1474页，32.3.3</div></div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [10].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="padding-left:40px;">翻译如下：</div><div style="padding-left:40px;">    在某些情况下，多个引脚可以同时驱动单个模块输入引脚，这种情况下就需要添加一个级别IOMUXing寄存器。</div><div style="padding-left:40px;">所有的信号都是多路复用的，所以需要一个专门的软件控制寄存器来控制这些多路复用器来选择输入路径。具体操作如下：   </div><ul><li><div><span style="color: #FF0000;">选择该引脚的复用功能（可通过IOMUXC_SW_MUX_CTL_&lt;PAD&gt;寄存器）</span></div></li><li><div><span style="color: #FF0000;">选择各多路复用器的输入路径（可通过Daisy Chain registers）</span></div></li></ul><div>     比如下图中：A、B、C三个引脚都可以设置为工作于Module X，它们都可以驱动Module  X。但是使用哪一个引脚呢？还需要设置“Daisy Chain select”，用来选择A、B、C之一。</div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [11].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="padding-left:40px;">     对于UART1_RX引脚，我们除了设置<b>IOMUXC_SW_MUX_CTL_PAD_UART1_RX_DATA</b>让它工作于ALT0之外，还需要设置寄存器<span style="color: #FF0000;"><b>IOMUXC_UART1_RX_DATA_SELECT_INPUT</b></span>，如下图所示：</div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [12].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>     在上图中，引脚GPIO1_IO02设置为ALT8模式时，它也可以用作UART1的RX输入引脚；引脚UART1_RX设置为ALT0模式时，它也可以用作UART1的RX输入引脚。<b>就是说你所用到的模块具体输入引脚在这还需要再进行选择。</b></div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div><span style="color: #FF0000;"><b>使用的模块是否有需要进行该寄存器的选择，得看芯片手册上有没有自己的所用到的模块,注意这些最后后缀为INPUT的，在里面选择所使用的引脚输入。（该部分截图来自芯片手册IOMUX部分）</b></span></div></div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [13].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><hr/><div><br/></div><div><span style="color: #FF0000;"><b>UART1_RX为何可以选择那么多引脚？请看下图：</b></span></div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [14].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><ul><li><div>UART1的发送引脚有2个选择：GPIO1_IO02、UART1_TX，假设选择了UART1_TX作为发送引脚。</div></li><li><div>UART1的接收引脚有2个选择：GPIO1_IO03、UART1_RX，假设选择了UART1_RX作为接收引脚。</div></li></ul><div>     但是UART1的模块还可能通过daisy引脚再次选择：GPIO1_IO02、GPIO1_IO03、UART1_TX、UART1_RX中的某一个。比如上图中，选择UART1_TX时，这就构成了回环，可以用于测试：IMX6ULL发出去的数据直接返回给自己；选择UART_RX是，就可以接收外面设备比如PC机的数据。</div><div>     在daisy中选择哪一个引脚连接到UART1模块？还需要进一步设置，代码如下(我们选择引脚UART1_RX)：</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div><span style="color: rgb(51, 51, 51);">IOMUXC_UART1_RX_DATA_SELECT_INPUT               = (volatile unsigned int  *)(0x20E0624); *IOMUXC_UART1_RX_DATA_SELECT_INPUT = 3;</span></div></div><h3>2.2.3 配置UART1_TX硬件参数</h3><div style="padding-left:40px;">寄存器：IOMUXC_SW_PAD_CTL_PAD_UART1_TX_DATA。</div><div>参考章节<a href="03 IMX6ULL裸机开发：普适的GPIO引脚操作方法概述.html" rev="en_rl_none">03 IMX6ULL裸机开发：普适的GPIO引脚操作方法概述</a>，经过比对，我们使用默认值（0x10b0）即可，无需配置。</div><div>打开芯片手册，找到该寄存器</div><div>该寄存器的理解可以参考：https://blog.csdn.net/u010168781/article/details/77855666</div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [15].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="657px"/><div>默认值为10110000其中</div><ul><li><div>速度设置为100MHz</div></li><li><div>DSE（驱动能力）</div></li><li><div>SRE（转换字段）：这是一个可以调整高低电平切换上升和下降时间速度的设置项，在一般的应用中使用芯片默认的设置就可以了。在需要微调SI或EMI性能时可以尝试修改配置</div></li></ul><h3>2.2.4 配置UART1_RX硬件参数</h3><div style="padding-left:40px;">寄存器：IOMUXC_SW_PAD_CTL_PAD_UART1_RX_DATA。</div><div>参考章节<a href="03 IMX6ULL裸机开发：普适的GPIO引脚操作方法概述.html" rev="en_rl_none">03 IMX6ULL裸机开发：普适的GPIO引脚操作方法概述</a>， 经过比对，我们使用默认值（0x10b0）即可，无需配置。</div><div style="text-align:center;"><span style="color: #FF0000;">（大致同上）</span></div><h2>2.3 设置串口参数</h2><h3>2.3.1 设置数据格式</h3><div><span style="color: #FF0000;"><span style="background-color: #fff199;">配置寄存器UART1_UCR2（0x2020084）</span></span></div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [16].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [17].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><div>设置UART1传输格式</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>UART1-&gt;UCR2 |= (1&lt;&lt;14) |(1&lt;&lt;5) |(1&lt;&lt;2)|(1&lt;&lt;1);</div></div><div style="padding-left:80px;"><span style="color: #FF0000;">[14]:   1：忽略RTS引脚</span></div><div style="padding-left:80px;"><span style="color: #FF0000;">[8] :   0: 关闭奇偶校验     默认为0，无需设置</span></div><div style="padding-left:80px;"><span style="color: #FF0000;">[6] :   0: 停止位1位        默认为0，无需设置</span></div><div style="padding-left:80px;"><span style="color: #FF0000;">[5] :   1: 数据长度8位</span></div><div style="padding-left:80px;"><span style="color: #FF0000;">[2] :   1: 发送数据使能</span></div><div style="padding-left:80px;"><span style="color: #FF0000;">[1] :   1: 接收数据使能</span></div><div><br/></div><h3>2.3.2 IMX6ULL芯片要求必须设置</h3><div><span style="color: #FF0000;"><span style="background-color: #fff199;"><b>配置寄存器UART1_UCR3（0x2020088）</b></span></span></div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [18].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [19].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><div>根据官方文档表示 [RXDMUXSEL]需要设置为1。</div><div>[2]:  1:IM6ULL的UART用了这个MUXED模型，因此这一位需要置位为1   </div><div>设置串口模型</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>UART1-&gt;UCR3 |= (1&lt;&lt;2);</div></div><h3>2.3.3 设置UART模块状态机的时钟</h3><div style="--en-callout:true;"><div>寄存器UART1_UFCR（0x2020090）</div></div><div><br/></div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [20].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [21].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>UART1_UFCR[9-7]：UART的时钟源分频系数</div><div>我们选择101（即十进制的5），表示不分频。</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>UART1-&gt;UFCR = 5 &lt;&lt; 7;       /* Uart的时钟clk：80MHz */</div></div><h3>2.3.4 设置波特率</h3><div><span style="color: #FF0000;"> <span style="background-color: #fff199;"><b>寄存器UART1_UBIR（0x20200A4）, UART1_UBMR（0x20200A8）</b></span></span></div><div>通过设置<span style="background-color: #fff199;"><b>UART1_UBIR与UART1_UBMR</b></span>，最终确定波特率。</div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [22].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [23].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="--en-callout:true;"><div>IMX6ULL波特率计算公式：</div></div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [24].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="padding-left:40px;">a.设置115200的波特率即BaudRate = 115200；</div><div style="padding-left:40px;">b.UART1的时钟频率前面内容已确定80Mhz即Ref Freq = 80000000；</div><div style="padding-left:40px;">c.IMX6ULL波特率计算公式得115200 = 80000000 /(16*(UBMR + 1)/(UBIR+1))；</div><div style="padding-left:40px;">d.选取一组满足上式的参数：UBMR、UBIR即可；</div><div style="padding-left:40px;">e. UART1_UBIR = 71  ； UART1_UBMR = 3124</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div> UART1-&gt;UBIR = 71;</div><div>UART1-&gt;UBMR = 3124;</div></div><h2>2.4 使能UART1</h2><div><span style="color: #FF0000;">虽然给UART提供了时钟，但是UART本身并未使能，</span>需要设置以下寄存器：</div><div>使能UART1，UART1_UCR1(0x2020080)寄存器如下：</div><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [25].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/Image [26].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>配置UART1_UCR1[0]：1表示使能UART， 0表示关闭UART。</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>Base-&gt;UCR1 |= (1 &lt;&lt; 0);        /*使能当前串口*/</div></div><h2>2.5 根据状态寄存器读写数据</h2><h3>2.5.1 状态寄存器</h3><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/017_uart_usr2.png" type="image/png" data-filename="017_uart_usr2.png" style="--en-uploadstate:uploaded;"/><h3>2.5.2 接收数据寄存器</h3><div><b>（和发送数据寄存器一样，是移植printf的关键）</b></div><p>读这个寄存器，就可读取串口数据，如下图：</p><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/018_uart_urxd.png" type="image/png" data-filename="018_uart_urxd.png" style="--en-uploadstate:uploaded;"/><h3>2.5.3 发送数据寄存器</h3><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/019_uart_utxd.png" type="image/png" data-filename="019_uart_utxd.png" style="--en-uploadstate:uploaded;"/><h1>三、代码附件</h1><a href="10 IMX6ULL裸机开发：程序示例（UART编程）_files/uart.zip"><img src="10 IMX6ULL裸机开发：程序示例（UART编程）_files/7a2e629324908c7dab021efe183f8993.png" alt="uart.zip"></a><div style="--en-callout:true;"><div>Makefile文件中GCC 选项-nostdlib作用</div></div><div>简要阐述该参数作用：避免C编译器链接电脑上的启动文件</div><div>详情查看该链接：https://blog.csdn.net/clb1609158506/article/details/41381561</div></span>
</div></body></html> 