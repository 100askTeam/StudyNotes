<html>
<head>
  <title>05 IMX6ULL裸机开发：LED程序所涉及的编程知识整理（其他笔记链接整理）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605138 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <meta name="content-class" content="yinxiang.superNote"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="747"/>
<h1>05 IMX6ULL裸机开发：LED程序所涉及的编程知识整理（其他笔记链接整理）</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2021/12/30 15:51</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/1/17 21:16</i></td></tr>
<tr><td><b>作者：</b></td><td><i>gi51wa2j</i></td></tr>
<tr><td><b>标签：</b></td><td><i>100ask_IMX6ULL_v11, bingo, 正文</i></td></tr>
</table>
</div>
<br/>

<div><span><h1>一、ARM架构了解</h1><div><a href="evernote:///view/38694434/s14/aa1fcbfb-1950-47e3-b278-852a64161282/aa1fcbfb-1950-47e3-b278-852a64161282/" rev="en_rl_none">ARM处理器程序运行的过程|ARM架构简单介绍（寄存器组|RISC与CISC）</a></div><h1>二、汇编学习</h1><div><a href="evernote:///view/38694434/s14/2d282506-79f3-4bdc-8751-f0591cad4448/2d282506-79f3-4bdc-8751-f0591cad4448/" rev="en_rl_none">CPU如何读取数据并写入内存</a></div><div><a href="evernote:///view/38694434/s14/602b70e0-0fb6-4f0c-b729-61b219f77394/602b70e0-0fb6-4f0c-b729-61b219f77394/" rev="en_rl_none">汇编指令（重点|常用）</a></div><h1>三、大小端和位操作</h1><div><a href="evernote:///view/38694434/s14/8e85bd7e-6ae2-49ec-a769-a79956e45118/8e85bd7e-6ae2-49ec-a769-a79956e45118/" rev="en_rl_none">进制转换（2进制|8进制|16进制）</a></div><div><a href="evernote:///view/38694434/s14/fbad2010-ba43-4115-a371-c9d7bec2fedf/fbad2010-ba43-4115-a371-c9d7bec2fedf/" rev="en_rl_none">字节序问题：大端法、小端法</a></div><div><a href="evernote:///view/38694434/s14/22bb2af8-800f-4b64-b30c-68bcd5e20f32/22bb2af8-800f-4b64-b30c-68bcd5e20f32/" rev="en_rl_none">C语言中常见的位操作</a></div><h1>四、汇编程序调用C程序</h1><div><a href="evernote:///view/38694434/s14/c3288bc3-e0e9-4d41-98b7-9ba9c03ff72e/c3288bc3-e0e9-4d41-98b7-9ba9c03ff72e/" rev="en_rl_none">汇编程序调用C程序</a></div><h1>五、C语言读写寄存器</h1><div><span style="background-color: #ffff00;"><b>       注意，我们说的这些寄存器不是CPU内部的寄存器，而是CPU之外、芯片上的某个模块里的寄存器。这些寄存器跟内存的访问方法是一样的。</b></span></div><p>        每一个寄存器都有一个地址，只要找到寄存器地址，通过指针指向寄存器地址单元，通过读写指针值，就可以获得寄存器值。</p><p>       首先，定义一个指针，指针类型根据寄存器大小决定，同时需要加上volatile关键字让编译器不要优化此指针，比如，CCM_CCGR1寄存器值是32位，此处定义为unsigned int *指针类型，寄存器地址为0x20C406C</p><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">volatile unsigned int *CCM_CCGR1 = (volatile unsigned int *)(0x20C406C);</div><p>然后，对寄存器进行读写操作</p><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">val = *CCM_CCGR1;       //读寄存器
*CCM_CCGR1 |= (3&lt;&lt;30);  //写寄存器，将CCM_CCGR1寄存器的[31：30]位置1</div><h1>六、start.S解析</h1><div><b>代码</b>：</div><a href="05 IMX6ULL裸机开发：LED程序所涉及的编程知识整理（其他笔记链接整理）_files/start.S"><img src="05 IMX6ULL裸机开发：LED程序所涉及的编程知识整理（其他笔记链接整理）_files/36fa033f811f8d09e8e0b5a15e48e025.png" alt="start.S"></a><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>2 .text</div><p>3 .global _start</p><p>4 _start:</p></div><ul><li><p>第2行，.text表示代码段，汇编系统预定义段名，说明下面的汇编是代码段</p></li><li><p>第3行，.global表示_start是一个全局符号</p></li><li><p>第4行，标签_start，<b>汇编程序的默认入口是_start，也可以在链接脚本中使用ENTRY来指明其它的入口点，类似C语言main()函数，_start是整个程序的入口</b>，即程序执行的第一条指令</p></li></ul><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><p>@相当于一个函数，_start是函数名，下面汇编指令是函数内容</p><p>4 _start:</p><p>5</p><p>6   //设置栈</p><p>7   ldr sp,=0x80200000</p><p>8</p><p>9   bl clean_bss</p><p>10</p><p>11 bl main</p><p>12</p><p>13 halt:</p><p>14 b halt</p></div><ul><li><p>第7行，将0x80200000赋值给寄存器sp，即设置栈地址，因为C语言函数调用时，保存现场/上下文和传递参数需要用到栈</p></li><li><p>第9行，跳转到标签clean_bss，相当于调用clean_bss函数，并将bl main指令地址存储到寄存器lr中</p></li><li><p> 第11行，进入C语言的main()函数，并将b halt指令地址存储到寄存器lr中</p></li><li><p>第13行，标签halt</p></li><li><p>第14行，跳转到标签halt，循环执行b halt指令执行，这就是一个死循环。如果main函数返回，就在这里死循环。</p></li></ul><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><p> @相当于一个函数，clean_bss是函数名，下面汇编指令是函数内容</p><p>16 clean_bss:</p><p>17  /*清除BSS段*/</p><p>18 ldr r1, =__bss_start</p><p>19 ldr r2, =__bss_end</p><p>20 mov r3, #0</p><p>21 clean:       @下面汇编指令相当于循环体，直到R1与R2相等</p><p>22 str r3, [r1]</p><p>23 add r1, r1, #4</p><p>24 cmp r1, r2</p><p>25 bne clean</p><p>26</p><p>27 mov pc, lr @函数执行完毕，返回</p></div><ul><li><p>第16行，标签clean_bss，下面汇编代码是清除BSS段，将BSS段所在内存都设置成0</p></li><li><p>第18行，将链接脚本定义的bss起始地址赋值给寄存器r1</p></li><li><p>第19行，将链接脚本定义的bss结束地址赋值给寄存器r2</p></li><li><p>第20行，将0赋值给寄存器r3，即r3=0</p></li><li><p>第21行，标签clean</p></li><li><p>第22行，将寄存器r3的值存储到寄存器r1的值对应地址中</p></li><li><p>第23行，将寄存器r1的值加上4，赋值给寄存器r1，即r1 = r1+4</p></li><li><p>第24行，比较寄存器r1的值与寄存器r2的值</p></li><li><p>第25行，如果寄存器r1的值与寄存器r2的值不相等，跳转到标签clean</p></li><li><p>第26行，如果寄存器r1的值与寄存器r2的值相等，就执行此行，返回到 bl main 处，继续执行</p></li></ul><h1>七、根据反汇编文件led.dis分析代码的整理运行流程</h1><div><b>代码</b>：</div><a href="05 IMX6ULL裸机开发：LED程序所涉及的编程知识整理（其他笔记链接整理）_files/led.dis"><img src="05 IMX6ULL裸机开发：LED程序所涉及的编程知识整理（其他笔记链接整理）_files/94b68c8d1538f986849c159bf224ed23.png" alt="led.dis"></a><h2>7.1 led.bin复制到DDR过程</h2><div><span style="background-color: #ffff00;"><b>在分析led.dis文件前，我们再把imx6ull芯片如何将led.bin文件复制到内存DDR中过程，简单整体过一篇。</b></span></div><div>          如下图，imx6ull芯片一上电后，会先执行bootRom程序，此程序是芯片出厂时已经固定的程序，除了芯片原厂，咱们是无法修改的。</div><img src="05 IMX6ULL裸机开发：LED程序所涉及的编程知识整理（其他笔记链接整理）_files/Image.png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="668px"/><h3>7.1.1 bootROM作用</h3><div><span style="background-color: #ffff00;"><b>bootRom有什么作用？下面一一讲解。</b></span></div><div>1. bootRom会把EMMC或TF卡的前4K数据读入到芯片内部RAM运行</div><div>2. bootRom根据DCD进行初始化DDR。</div><div>3. bootRom根据IVT，从EMMC或TF卡中将led.bin读到DDR的0x80100000地址</div><div>4. 跳转到DDR的0x80100000地址执行<b>（程序执行地址是makefile文件中指定的）</b></div><img src="05 IMX6ULL裸机开发：LED程序所涉及的编程知识整理（其他笔记链接整理）_files/Image [1].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>7.2 查看机器码</h2><div> 目前led.bin程序已经复制到内存中，<b>CPU开始从内存0x80100000地址开始执行机器码</b>，每一条机器码是32位/4字节，此处的机器码就是led.bin中的机器码，那我们能不能打开led.bin文件，看到里面的机器码？答案是可以的。如下图:</div><img src="05 IMX6ULL裸机开发：LED程序所涉及的编程知识整理（其他笔记链接整理）_files/Image [2].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="352px"/><div>         前面介绍过大/小端模式，你是否记得？如果忘记了，可以回头看一下。</div><div>         此处可以看到机器码e59fd028（指令：ldr sp,=0x80200000）的存储形式：</div><table align="center" cellpadding="0" cellspacing="0" style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:664px;" width="664px"><colgroup><col style="width: 334px;"></col><col style="width: 330px;"></col></colgroup><tbody><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div style="text-align:center;">地址</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div style="text-align:center;">机器码</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div style="text-align:center;">00000000</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div style="text-align:center;">28</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div style="text-align:center;">00000001</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div style="text-align:center;">d0</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div style="text-align:center;">00000002</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div style="text-align:center;">9f</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div style="text-align:center;">00000003</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div style="text-align:center;">e5</div></td></tr></tbody></table><div style="padding-left:80px;"><span style="background-color: #ffff00;"><b>错，imx6ull的存储方式是小端模式，换一句话说，ARM存储方式一般都是小端模式。</b></span></div><div>             但是bin文件的机器码不方便阅读，所以我们一般会通过<span style="background-color: #ffff00;">arm-linux-gnueabihf-objdump进行反汇编</span>，得到人类容易读的<span style="background-color: #ffff00;">led.dis文件。</span></div><h2>7.3 反汇编led.dis分析</h2><div style="text-align:center;">如下图:</div><img src="05 IMX6ULL裸机开发：LED程序所涉及的编程知识整理（其他笔记链接整理）_files/Image [3].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="818px"/><div><b>下面我们就来分析一下led.dis文件，但是在阅读此小节前，尽量把前一小节《start.S解析》完全理解懂，不然阅读此小节，有点云里雾里。</b></div><div><span style="background-color: #ffff00;">1)  CPU执行的第一条机器码就是内存地址0x80100000存储的e59fd028机器码</span></div><div style="padding-left:40px;">对应的指令是“ldr sp, [pc, #40]”，相当于Start.S文件的“ldr  sp,=0x80200000”指令。</div><div style="padding-left:40px;">执行完后，寄存器SP的值等于0x80200000。</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>80100000: e59fd028 ldr sp, [pc, #40] ; 80100030 &lt;clean+0x14&gt;</div></div><div><span style="background-color: #ffff00;">2)  每执行完一条机器码，会自动执行下一个内存地址0x80100004存储的eb000001机器码</span></div><div style="padding-left:40px;">对应的指令是“bl  80100010”，相当于Start.S文件的“bl clean_bss”指令。</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>80100004: eb000001 bl 80100010 &lt;clean_bss&gt;</div><div>....</div><div>80100010 &lt;clean_bss&gt;:</div><div>80100010: e59f101c ldr r1, [pc, #28] ; 80100034 &lt;clean+0x18&gt;</div><div>80100014: e59f201c ldr r2, [pc, #28] ; 80100038 &lt;clean+0x1c&gt;</div></div><div><span style="background-color: #ffff00;">3)  跳转到内存地址0x80100010，执行e59f101c机器码，对应的指令是ldr r1, [pc,  #28]</span></div><div style="padding-left:40px;">相当于Start.S文件的“ldr r1, =__bss_start”指令。</div><div><span style="background-color: #ffff00;">4)  此处clean_bss相当于一个函数，CPU会逐条执行指令，直到执行“mov pc, lr”指令后，才返回。</span></div><div style="padding-left:40px;"><b>返回哪里？</b>返回内存地址0x80100008处执行fa000057机器码，对应的指令是“blx  8010016c”。</div><div style="padding-left:40px;">对应Start.S文件的“bl main”指令。</div><div>到此，CPU跳转到C语言的main()函数，继续执行。</div><h2>7.4 main函数分析</h2><div><span style="background-color: #ffff00;"><b>为了让大家深入理解C语言函数的调用执行过程中，汇编指令如何执行，此处简单分析main()函数</b></span></div><img src="05 IMX6ULL裸机开发：LED程序所涉及的编程知识整理（其他笔记链接整理）_files/Image [4].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="821px"/><div><br/></div><div>如上图所示</div><div>1. <b>进入main()函数后，先将寄存器R7、LR入栈</b>，保存现场/上下文，方便main()函数执行完毕后返回，并且<b>将当前栈指向的内存地址赋值给寄存器R7</b>，如图</div><img src="05 IMX6ULL裸机开发：LED程序所涉及的编程知识整理（其他笔记链接整理）_files/Image [5].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="827px"/><div><br/></div><div>2.<b> 调用led_init()函数</b>，因为没有参数传递，<b>所以直接调用BL指令进行跳转</b>，即“bl  8010003c”指令。</div><div>3.<b> 调用led_ctl(1)函数，此处只有一个参数，通过寄存器R0进行传递，</b>即“movs r0,  #1”指令，然后<b>通过BL指令进行跳转</b>，即“bl 801000f8”指令，关于参数传递问题，可以参考前面《5.6 汇编程序调用C程序》。</div><div>4. <b>调用delay(1000000)函数，此处只有一个参数，通过寄存器R0进行传递</b>，然后通过<b>BL指令进行跳转</b>。</div><div>5. 调用<b>led_ctl(0)函数，此处只有一个参数，通过寄存器R0进行传递</b>，然后通过<b>BL指令进行跳转。</b></div><div>6. 调用<b>delay(1000000)函数，此处只有一个参数，通过寄存器R0进行传递</b>，然后通过<b>BL指令进行跳转。</b></div><div>7.<b> while(1)循环体到此已经结束，但是需要循环执行循环体的内容，通过B指令进行跳转到循环体开头，</b>即“b.n 80100174”指令，执行内存地址0x80100174处的指令，也就是led_ctl(1)函数对应的汇编指<b>令“movs r0, #1”。</b></div><div><br/></div><div>到此，进入并执行main()函数对应的汇编指令分析已经结束，如果读者有兴趣可以分析一下，led_init()、led_ctl()与delay()函数的汇编指令。</div><div><br/></div></span>
</div></body></html> 