<html>
<head>
  <title>数据段（bss段、data段、rodata段）、代码段（text段）、堆（heap）、栈（stack）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605138 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <meta name="content-class" content="yinxiang.superNote"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="1734"/>
<h1>数据段（bss段、data段、rodata段）、代码段（text段）、堆（heap）、栈（stack）</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2022/2/21 1:00</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/2/22 18:55</i></td></tr>
<tr><td><b>作者：</b></td><td><i>gi51wa2j</i></td></tr>
<tr><td><b>标签：</b></td><td><i>bingo, 计算机原理, 细节知识</i></td></tr>
</table>
</div>
<br/>

<div><span><h1>1. 嵌入式中的全局变量</h1><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);"> </span></span></span>    <span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">全局变量是放在全局内存中的，但反过来却未必成立。用static修饰的局部变量就是放在放全局内存的，它的作用域是局部的，但生命期是全局的。在有的嵌入式平台中，堆实际上就是一个全局变量，它占用相当大的一块内存，在运行时，把这块内存进行二次分配。这里我们并不强调全局变量和全局内存的差别。在本文中，全局强调的是它的生命期，而不是它的作用域，所以有时可能把两者的概念互换。</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">    一般来说，在一起定义的两个全局变量，在内存的中位置是相邻的。这是一个简单的常识，但有时挺有用，如果一个全局变量被破坏了，不防先查查其前后相关变量的访问代码，看看是否存在越界访问的可能。</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">    在ELF(Executable and Linkable Format)格式的可执行文件中，全局内存包括三种：bss、data和rodata。其它可执行文件格式与之类似。了解了这三种数据的特点，我们才能充分发挥它们的长处，达到速度与空间的最优化。</span></span></span></div><h1>2. bss段</h1><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">  </span></span></span>            <span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);"> 又叫ZI(zero inital)段，通俗的说，bss是指那些没有初始化的和初始化为0的全局变量。</span></span></span></div><div style="padding-left:40px;"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);"> 由原文的例子可见：bss类型的全局变量只占运行时的内存空间，而不占文件空间。</span></span></span></div><div style="padding-left:40px;"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">注：多数操作系统，在加载程序时，会把所有的bss全局变量全部清零，无需要你手工去清零。但为保证程序的可移植性，手工把这些变量初始化为0也是一个好习惯。</span></span></span></div><h1>3. data段</h1><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);"> </span></span></span>           <span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">通俗的说，data指那些初始化过（非零）的非const的全局变量。如果数据全是零，为了优化考虑，编译器把它当作bss处理。所以bss属于一个特殊的data。</span></span></span></div><div style="padding-left:40px;"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">      由原文的例子可见：data类型的全局变量是即占文件空间，又占用运行时内存空间的。</span></span></span></div><div style="--en-callout:true;"><div style="text-align:center;">数据段包含了bss段和data段</div></div><h1>4. rodata段（只读数据段）</h1><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">   rodata的意义同样明显，ro代表read only，即只读数据(const)。关于rodata类型的数据，要注意以下几点：</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">         1.常量不一定就放在rodata里，有的立即数直接编码在指令里，存放在代码段(.text)中。</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">         2.对于字符串常量，编译器会自动去掉重复的字符串，保证一个字符串在一个可执行文件(EXE/SO)中只存在一份拷贝。</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">         3.rodata是在多个进程间是共享的，这可以提高空间利用率。</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">         4.在有的嵌入式系统中，rodata放在ROM(如norflash)里，运行时直接读取ROM内存，无需要加载到RAM内存中。</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">         5.在嵌入式linux系统中，通过一种叫作XIP（就地执行）的技术，也可以直接读取，而无需要加载到RAM内存中。</span></span></span></div><div><br/></div><div style="padding-left:40px;"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">      由此可见，把</span><span style="color: #FF0000;"><b>在运行过程中不会改变的数据设为rodata类型的，是有很多好处的</b></span><span style="color: rgb(31, 9, 9);">：在多个进程间共享，可以大大提高空间利用率，甚至不占用RAM空间。同时由于rodata在只读的内存页面(page)中，是受保护的，任何试图对它的修改都会被及时发现，这可以帮助提高程序的稳定性。</span></span></span></div><h1>5. text段（代码段）</h1><div><span style="font-size: 14px;"><span style="font-family: PingFang SC, Microsoft YaHei, Helvetica Neue, Helvetica, Arial, sans-serif;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;">　</span></span></span></span><span style="font-size: 18px;"><span style="font-family: 黑体;"><span style="color: rgb(51, 51, 51);"><span style="font-weight: bold;">代码段（code segment/text segment）</span>通常是指用来存放程序执行代码的一块内存区域。</span></span></span></div><div><span style="font-size: 18px;"><span style="font-family: 黑体;"><span style="color: rgb(51, 51, 51);">　　这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)（在STMF103ZET6中，代码段存放在flash中，而可读可写的数据段存放在RAM中，也就是内存中）。</span></span></span></div><div><span style="font-size: 18px;"><span style="font-family: 黑体;"><span style="color: rgb(51, 51, 51);">　　在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 </span></span></span></div><h1>6. 堆（heap）</h1><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">    堆管理器是操作系统的一个模块。是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</span></span></span></div><div style="padding-left:40px;"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">      堆的特点：</span></span></span></div><div style="padding-left:40px;"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">　　　　需要手动申请（malloc）和释放（free）</span></span></span></div><div style="padding-left:40px;"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">　　　　脏内存，</span></span></span></div><div style="padding-left:40px;"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">　　　　临时性（在malloc和free之间能访问）。</span></span></span></div><div style="padding-left:40px;"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">　　（注：在测试的时候，堆free还能访问其内部的内存，但是内部的内存值可能不正确了。）</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">　　　　memset(p,0,10);//memset是对p当前位置后面的10个字节赋予0的初值。通常用于清0。</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">　　　　malloc返回的是一个void类型的指针。返回的值表示一个内存地址。失败返回NULL。</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">　　　　使用的过程：申请(malloc)-&gt;检验是否为空内存-&gt;使用申请的内存-&gt;释放申请的内存（free(p)）。</span></span></span></div><div style="padding-left:40px;"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">　　　　malloc位于stdlib这个头文件中。</span></span></span></div><div style="padding-left:40px;"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">　　　　&quot;程序泄露&quot;又叫&quot;吃内存&quot;</span></span></span></div><div style="padding-left:40px;"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">　　　　gcc（linux）中int malloc(0)其实不是没有分配内存，它分配了0x10个内存；gcc默认返回最小16字节的内存块。</span></span></span></div><h1>7. 栈（heap）</h1><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">      栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</span></span></span></div><div style="padding-left:40px;"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">栈的特点：</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">　　　　　反复使用，先进后出，脏内存，临时性（函数不能返回栈变量的指针），栈会溢出。</span></span></span></div><div><span style="font-size: 18px;"><span style="font-family: PingFang SC, Microsoft YaHei, Helvetica Neue, Helvetica, Arial, sans-serif;"><span style="color: rgb(51, 51, 51);">　　从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。 </span></span></span></div><h1>8. 变量与关键字</h1><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">static关键字用途太多，以致于让新手模糊。不过，总结起来就有两种作用，改变生命期和限制作用域。如：</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">         1.修饰inline函数：限制作用域</span></span></span><a href="evernote:///view/38694434/s14/00000000-0000-0000-0000-000000000000/eed00646-2c24-4466-b671-419c28fedf49-2343/"><span style="font-size: 16px;"><span style="font-family: PT Serif;">static和inline配合修饰函数</span></span></a></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">         2.修饰普通函数：限制作用域</span></span></span></div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>  用static修饰的函数，本限定在本源码文件中，不能被本源码文件以外的代码文件调用</div></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">         3.修饰局部变量：改变生命期</span></span></span></div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。  </div><div>       static局部变量只被初始化一次，下一次依据上一次结果值； </div></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">         4.修饰全局变量：限制作用域</span></span></span></div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div><span style="background-color: #ffffff;"><span style="font-weight: 400;">静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。 </span></span></div><div><span style="color: #FF0000;"><span style="background-color: #ffffff;"><span style="font-weight: 400;">static全局变量只初使化一次，防止在其他文件单元中被引用; </span></span></span></div></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">const 关键字倒是比较明了，用const修饰的变量放在rodata里，字符串默认就是常量。对const，注意以下几点就行了。</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">         1.指针常量：指向的数据是常量。如 const char* p = “abc”; p指向的内容是常量 ，但p本身不是常量，你可以让p再指向”123”。(注：其中的“abc”是放在代码段(.text)的,这个的格式也可以写为   char const *p=&quot;abc&quot;;  )</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">         2.常量指针：指针本身是常量。如：char* const p = “abc”; p本身就是常量，你不能让p再指向”123”。</span></span></span></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">         3.指针常量 + 常量指针：指针和指针指向的数据都是常量。const char* const p =”abc”; 两者都是常量，不能再修改。</span></span></span></div><div><br/></div><div><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);"> </span></span></span>    <span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">violatile关键字通常用来修饰多线程共享的全局变量和IO内存。告诉编译器，不要把此类变量优化到寄存器中，每次都要老老实实的从内存中读取，因为它们随时都可能变化。这个关键字可能比较生僻，但千万不要忘了它，否则一个错误让你调试好几天也得不到一点线索。</span></span></span></div><div style="padding-left:40px;"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(31, 9, 9);">（注：这个相当于stm32文件中定义的__IO，代表了每次读取用这个关键词定义的值的时候，需要去内存中实时的读取。也就是说每次得到的都是最新的值）</span></span></span></div><div><br/></div><h1>9. 参考文章</h1><div><a href="http://blog.csdn.net/sunny04/article/details/40627311"><span style="font-family: PT Serif;"><span style="color: rgb(6, 85, 136);">http://blog.csdn.net/sunny04/article/details/40627311</span></span></a></div><div><a href="http://blog.csdn.net/jxhui23/article/details/8064766"><span style="font-size: 16px;"><span style="font-family: PT Serif;"><span style="color: rgb(6, 85, 136);">http://blog.csdn.net/jxhui23/article/details/8064766</span></span></span></a></div><div><br/></div></span>
</div></body></html> 