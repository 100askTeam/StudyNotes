<html>
<head>
  <title>ARM处理器程序运行的过程|ARM架构简单介绍（寄存器组|RISC与CISC）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605138 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="890"/>
<h1>ARM处理器程序运行的过程|ARM架构简单介绍（寄存器组|RISC与CISC）</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2022/1/11 14:25</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/5/6 15:18</i></td></tr>
<tr><td><b>作者：</b></td><td><i>gi51wa2j</i></td></tr>
<tr><td><b>标签：</b></td><td><i>ARM, bingo, 计算机原理, 正文</i></td></tr>
</table>
</div>
<br/>

<div><span><h1>一、 ARM处理器程序运行的过程</h1><div><span style="background-color: #ffff00;">ARM芯片属于精简指令集计算机(RISC：Reduced Instruction Set Computing)，它所用的指令比较简单，有如下特点：</span></div><div>① 对内存只有<span style="background-color: #ffff00;">读、写</span>指令</div><div>② 对于数据的运算是在<span style="background-color: #ffff00;">CPU内部</span>实现</div><div>③ 使用RISC指令的CPU<span style="background-color: #ffff00;">复杂度小</span>一点，易于设计</div><div><br/></div><div>比如对于a=a+b这样的算式，需要经过下面4个步骤才可以实现：</div><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image.png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="405px"/><div>细看这几个步骤，有些疑问：</div><div><span style="background-color: #ffff00;">① 读a，那么a的值读出来后保存在CPU里面哪里？</span></div><div><span style="background-color: #ffff00;">② 读b，那么b的值读出来后保存在CPU里面哪里？</span></div><div><span style="background-color: #ffff00;">③ a+b的结果又保存在哪里？</span></div><div><br/></div><div>我们需要深入ARM处理器的内部。简单概括如下，我们<b>先忽略各种CPU模式(系统模式、用户模式等等)。</b></div><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image [1].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div><br/></div><div><br/></div><div>CPU运行时，<b>先去取</b>得指令，<b>再执行</b>指令：</div><div style="padding-left:40px;">① 把内存a的值读入CPU寄存器R0</div><div style="padding-left:40px;">② 把内存b的值读入CPU寄存器R1</div><div style="padding-left:40px;">③ 把R0、R1累加，存入R0</div><div style="padding-left:40px;">③   把R0的值写入内存a</div><div>现在，我们知道了：CPU内部有很多寄存器，CPU要从外部设备上读入指令，执行指令。</div><div><br/></div><h1>二、 ARM架构的简单介绍</h1><div><b>IMX6UL使用Cortex-A7架构</b>，本小节<b>简单介绍</b>一下Cortex-A7架构的基础知识，<b>比如运行模式、寄存器组等。</b></div><div><span style="color: #FF0000;"><b>参考资料</b>：</span></div><div style="padding-left:40px;">Ÿ  文件名：ARMv7编程手册(DEN0013D_cortex_a_series_PG).pdf </div><div style="padding-left:40px;">Ÿ  文档所在目录: 网盘开发板配套资料“ 08_Reference material (ARM,NXP参考资料)/Arm架构参考资料.zip”</div><div style="padding-left:40px;">Ÿ  参考章节: 《3: ARM Processor Modes and Registers》</div><h2><span style="color: #FF0000;"><b>2.1 地址空间_RISC与CISI（补充）</b></span></h2><div>对于ARM架构，访问内存还是访问外设或者外设的寄存器，都没有任何区别，因为ARM的地址范围都属于同一地址空间，这是ARM所特殊的地方。ARM有一个内存控制器，CPU发出的地址经过内存控制器，通过不同的地址来访问不同的内存或者外设。</div><div>假设外设中有一个EMMC controller，外接一个Flash，CPU发出的地址可以到达外设，但是不能到达Flash，想访问Flash必须通过EMMC控制器，这个类似于爷父子三级关系，不能跨级访问，CPU和EMMC所看到的零地址不是同一个东西。</div><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image [2].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>以x86架构来进行对比，内存空间和IO空间完全两回事，使用不同的指令来访问内存，两个地址不在同一个空间，</div><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image [3].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>2.1.1 RISC</h3><div><b>ARM芯片属于</b>精简指令集计算机(RISC：Reduced Instruction Set Computing)，它所用的指令比较简单，有如下特点：</div><p>① 对内存只有读、写指令</p><p>② 对于数据的运算是在CPU内部实现</p><p>③ 使用RISC指令的CPU复杂度小一点，易于设计</p><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image [4].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>2.1.2 CISC</h3><div>x86属于复杂指令集计算机(CISC：Complex Instruction Set Computing)，</div><p>它所用的指令比较复杂，比如某些复杂的指令，它是通过“微程序”来实现的。</p><p>比如执行乘法指令时，实际上会去执行一个“微程序”，</p><p>在“微程序”里，</p><p>一样是去执行这4不操作：</p><p>① 读内存a</p><p>② 读内存b</p><p>③ 计算a*b</p><p>④ 把结果写入内存</p><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image [5].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3><b>2.1.3CISC和RISC比较</b></h3><div><b>1.指令能力：</b>CISC的指令能力强，单多数指令使用率低却增加了CPU的复杂度，指令是可变长格式；RISC的指令大部分为单周期指令，指令长度固定。RISC对内存只有load/stoe操作，数据的运算都是在CPU内部实现。</div><div><b>2.寻址方式：</b>CISC支持多种寻址方式；RISC支持的寻址方式少；</div><div><b>3.实现方式：</b>CISC通过微程序控制技术实现；RISC增加了通用寄存器，硬布线逻辑控制为主，采用流水线方式执行。</div><div><b>4.研发周期：</b>CISC的研制周期长，RISC硬件简单，需要优化编译器，有效支持高级语言</div><h2><b>2.2 9种运行模式</b></h2><div><span style="background-color: #ffff00;">Cortex-A7架构的运行模式有9种，分别为User、Sys(System)、FIQ、IRQ、ABT(Abort)、SVC(Supervisor)、UND(Undef)、MON(Monitor)、Hyp模式</span>，如下表：</div><table align="center" cellpadding="0" cellspacing="0" style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:764px;" width="764px"><colgroup><col style="width: 190px;"></col><col style="width: 574px;"></col></colgroup><tbody><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>模式 </div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>描述</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>User</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>用户模式，非特权模式，大部分程序运行的时候就处于此模式</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>Sys(System)</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>系统模式，用于运行特权级的操作系统任务</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>FIQ</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>快速中断模式，进入 FIQ 中断异常</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>IRQ</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>一般中断模式</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>ABT(Abort)</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>数据访问终止模式，用于虚拟存储以及存储保护</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>SVC(Supervisor)</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>超级管理员模式，供操作系统使用</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>UND(Undef)</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>未定义指令终止模式</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>MON(Monitor)</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>用于安全扩展模式</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>Hyp</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>用于虚拟化扩展</div></td></tr></tbody></table><div><br/></div><div><span style="background-color: #ffff00;">除了User模式属于非特权模式，其它8种处理器模式都是特权模式。</span></div><div><b>运行模式</b>可以<b>通过软件进行任意切换，也可以通过中断或者异常来进行切换</b>。大多数的程序都运行在用户模式，用户模式下是不能访问系统所有资源的，有些资源是受限的，要想访问这些受限的资源就必须进行模式切换。但是<b>用户模式是不能直接进行切换的，用户模式下需要借助异常来完成模式切换，当要切换模式的时候，应用程序可以产生异常，在异常的处理过程中完成处理器模式切换</b>。</div><div>所谓“运行模式”，可以这样简单理解：</div><div>① 板子上电时，CPU处于SVC模式，它用的是SVC模式下的寄存器</div><div>② 程序运行时发生了中断，CPU进入IRQ模式，它用的IRQ模式下的寄存器</div><div>③ CPU处理完中断，它切换回SVC模式，继续使用SVC模式下的寄存器</div><div>④ CPU发生某种异常时，比如读取内存出错，它会进入ABT模式，使用ABT模式下的寄存器来处理错误。</div><div><span style="background-color: #ffff00;">在某种模式下，CPU执行时使用的是这种模式的资源，比如使用的是这组模式的寄存器。</span></div><div>这样就可以<b>免去保存上一个模式所使用的寄存器。</b></div><h1><b>三、 寄存器组介绍：M3、M4与A7</b></h1><div>无论cortex-M3/M4还是现在学习的A7，内部都有R0-R15这15个寄存器来“暂存”数据</div><div>这些是内核寄存器组，而不是类似GPIO寄存器等的芯片外设寄存器，这些寄存器CPU可以直接访问到。</div><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image [6].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="394px"/><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image [7].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="962px"/><div>sp_main：主栈寄存器</div><div><br/></div><h2><b>3.1 程序状态寄存器：APSR/IPSR/EPSR</b></h2><div style="text-align:center;"><b>（PSR全称：Program Status Register）</b></div><div><b>M3/M4的xPSR 实际上对应3个寄存器APSR/IPSR/EPSR</b></div><div>（三个寄存器的位是错开的，所以组合在一起，叫做xPSR）</div><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image [8].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="972px"/><div><b>MRS表示：Move to Register from Status，就是把Status寄存器的值移动到通用寄存器</b></div><div>（</div><div>MOV R1 R0的结果是：R1的值等于R0的值，后面的R0是源，前面的R1是目的；以此方便理解</div><div>  )</div><h2>3.2 程序状态寄存器：CPSR</h2><div><b>对于cortex A7的CPSR 寄存器</b></div><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image [9].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="964px"/><h2><b>3.3 M3/4与A7的程序状态寄存器对比</b></h2><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image [10].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="971px"/><div><b> Cortex-A7 内核寄存器组， </b></div><div>上一小节我们讲了<b> Cortex-A7 有 9 种运行模式，每一种运行模式都有一组与之对应的寄存器组</b>，如下图：</div><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/该图片IQR寄存器有误.png" type="image/png" data-filename="该图片IQR寄存器有误.png" style="--en-uploadstate:uploaded;" width="825px"/><div><span style="background-color: #ffff00;">浅色字体是与 User 模式所共有的寄存器</span>，<span style="background-color: #ffff00;">浅蓝色背景是各个模式所独有的寄存器</span>，即在所有的模式中，低寄存器组(R0~R7)是共享同一组物理寄存器的，只是一些高寄存器组在不同的模式有自己独有的寄存器，比如 FIQ 模式下 R8~R14 是独立的物理寄存器。<b>不同运行模式不同的寄存器有助于提高运行速度。</b></div><div>如果某个程序处于 FIQ 模式下访问寄存器 R13(SP)，那它实际访问的是寄存器 SP_fiq</div><div>如果某个程序处于 SVC 模式下访问寄存器 R13(SP)，那它实际访问的是寄存器 SP_svc</div><h2><b>3.4 4类寄存器介绍（对于ARMA7）</b></h2><div><b>9 种运行模式的寄存器合计有34个，可以分为：</b></div><div style="padding-left:40px;"><b>1. 未备份寄存器，即 R0~R7</b></div><div style="padding-left:40px;"><b>2. 备份寄存器，即 R8~R14</b></div><div style="padding-left:40px;"><b>3. 程序计数器 ，即 R15</b></div><div style="padding-left:40px;"><b>4. 程序状态寄存器</b></div><h3><span style="color: #FF0000;"><span style="background-color: #ffff00;"><b>① 未备份寄存器</b></span></span></h3><div>未备份寄存器指的是 R0~R7，因为在所有的运行模式下R0~R7寄存器都是同一个物理寄存器，在不同的模式下，R0~R7寄存器中的数据就会被破坏，所以R0~R7寄存器并没有被用作特殊用途。</div><h3><span style="color: #FF0000;"><span style="background-color: #ffff00;"><b>② 备份寄存器</b></span></span></h3><div>备份寄存器中的 R8~R12 寄存器有两种物理寄存器，在快速中断模式下(FIQ)它们对应着Rx_irq(x=8~12)物理寄存器，其他模式下对应着 Rx(8~12)物理寄存器。<b>FIQ 是快速中断模式，这个中断模式要求快速执行！因为 FIQ 模式下的 R8~R12 是独立的，因此中断处理程序可以不用保存和恢复R8~R12，从而加速中断的执行过程。</b></div><div><b>备份寄存器 R13(SP) ，也叫栈指针，有 8 个物理寄存器，其中一个是User和Sys模式共用的</b>，剩下的 7 个分别对应 7 种不同的模式。</div><div><b>备份寄存器 R14(LR) ，也叫链接寄存器，有 7 个物理寄存器，其中一个是User、Sys和Hyp模式所共有的，</b>剩下的 6 个分别对应 6 种不同的模式，主要有如下用途：</div><div><span style="background-color: #ffff00;">使用 R14(LR)来存放当前子程序的返回地址，如果使用 BL 或者 BLX来调用子函数的话，R14(LR)被设置成该子函数的返回地址，在子函数中，将 R14(LR)中的值赋给 R15(PC)即可完成子函数返回，如mov pc,lr</span></div><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image [11].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="970px"/><h3><span style="color: #FF0000;"><span style="background-color: #ffff00;"><b>③ 程序计数器 </b></span></span></h3><div><b>程序计数器 R15(PC)，保存着当前执行指令地址值加 8 个字节</b></div><div>因为<span style="background-color: #ffff00;">ARM处理器是三级流水线</span>：<span style="background-color: #ffff00;">取指-&gt;译码-&gt;执行</span>，循环执行。比如当前正在执行第一条指令的同时也对第二条指令进行译码，第三条指令也同时被取出存放在 R15(PC)中，即<b>  R15(PC)总是指向当前正在执行指令地址</b><span style="color: #FF0000;"><b>再加上 2 条指令的地址，</b></span><b>对于 32 位的 ARM 处理器，每条指令是 4 个字节，</b></div><div><b>    所以R15(PC) = 当前执行指令地址 + 8个字节</b></div><div><br/></div><h3><span style="color: #FF0000;"><span style="background-color: #ffff00;"><b>④ 程序状态寄存器</b></span></span></h3><div><b>程序状态寄存器PSR</b>可以分成<b>当前程序状态寄存器CPSR</b>与<b>备份程序状态寄存器SPSR。</b></div><div><b>所有运行模式都共用一个 CPSR 物理寄存器，因此 CPSR 可以在任何模式下被访问</b>，该寄存器包含条件标志位、中断禁止位、当前运行模式标志等一些状态位以及一些控制位。但是所有运行模式都共用一个 CPSR 必然会导致冲突<b>，因此除了 User 和 Sys 模式以外，其他  7 个模式都配备一个专用的物理状态寄存器，叫做 备份程序状态寄存器(SPSR)，当特定异常中断发生时，SPSR用来保存CPSR的值，当异常退出以后可以用 SPSR 中保存的值来恢复  CPSR。</b></div><div>    由于 SPSR 是 CPSR 的备份，因此 SPSR 和 CPSR 的寄存器结构相同，如下图：</div><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image [12].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="827px"/><div><span style="background-color: #ffff00;">N(bit31)：</span>当两个有符号整数运算(补码表示)时，结果用N表示，N=1/0 表示 负数/正数</div><div><span style="background-color: #ffff00;">Z(bit30)：</span>对于 CMP 指令，Z=1 表示进行比较的两个数大小相等</div><div><span style="background-color: #ffff00;">C(bit29)：</span></div><div><b>在加法指令中，当结果产生了进位，则C=1</b>，表示无符号数运算发生<b>上溢</b>，其它情况下  C=0</div><div><b>在减法指令中，当运算中发生借位，则C=0</b>，表示无符号数运算发生<b>下溢</b>，其它情况下  C=1</div><div><b>对于包含移位操作的非加/减法运算指令，C 中包含最后一次溢出的位的数值</b></div><div><b>对于其它非加/减运算指令，C 位的值通常不受影响</b></div><div><span style="background-color: #ffff00;">V(bit28)：</span>对于加/减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时，V=1 表示符号位溢出，通常其他位不影响 V 位</div><div><span style="background-color: #ffff00;">Q(bit27)：</span>仅 ARM v5TE_J 架构支持，表示饱和 状态，Q=1/0 表示累积饱和/累积不饱和</div><div><span style="background-color: #ffff00;">IT[1:0](bit26:25)</span> 和 <span style="background-color: #ffff00;">IT[7:2](bit15:bit10)</span>一起组成 IT[7:0]，作为 IF-THEN 指令执行状态</div><div><span style="background-color: #ffff00;">J(bit24)和T(bit5)</span>：控制指令执行状态，表明本指令是ARM指令还是Thumb指令，如表</div><table align="center" cellpadding="0" cellspacing="0" style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:656px;" width="656px"><colgroup><col style="width: 190px;"></col><col style="width: 190px;"></col><col style="width: 276px;"></col></colgroup><tbody><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>J</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>T</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>描述</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>0</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>0</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>ARM</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>0</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>1</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>Thumb</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>1</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>1</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>ThumbEE</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>1</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>0</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>Jazelle</div></td></tr></tbody></table><div><span style="background-color: #ffff00;">GE[3:0](bit19:16)：</span>SIMD 指令有效，大于或等于</div><div><span style="background-color: #ffff00;">E(bit9)</span>：大小端控制位，E=1/0 表示大/小端模式</div><div><span style="background-color: #ffff00;">A(bit8)：</span>禁止异步中断位，A=1 表示禁止异步中断</div><div><span style="background-color: #ffff00;">I(bit7)：</span>I=1/0 代表 禁止/使能 IRQ</div><div><span style="background-color: #ffff00;">F(bit6)：</span>F=1/0 代表 禁止/使能 FIQ</div><div><span style="background-color: #ffff00;">M[4:0]：</span>运行模式控制位，如表</div><div><br/></div><table align="center" cellpadding="0" cellspacing="0" style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:742px;" width="742px"><colgroup><col style="width: 288px;"></col><col style="width: 454px;"></col></colgroup><tbody><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>M[4:0]</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>运行模式</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>10000  </div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>User 模式</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>10001  </div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>FIQ 模式</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>10010  </div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>IRQ 模式</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>10011  </div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>Supervisor(SVC)模式</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>10110  </div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>Monitor(MON)模式</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>10111  </div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>Abort(ABT)模式</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>11010  </div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>Hyp(HYP)模式</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>11011  </div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>Undef(UND)模式</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>11111  </div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>System(SYS)模式</div></td></tr></tbody></table><h2><b>3.5 程序状态寄存器中的位（详细介绍）</b></h2><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image [13].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><img src="ARM处理器程序运行的过程ARM架构简单介绍（寄存器组RISC与CISC）_files/Image [14].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>3.6 补充</h2><div>我们说”寄存器”时，需要分辨是哪种：</div><div>1.CPU内部的寄存器</div><div>2.CPU之外设备自己的寄存器</div><div>这是不一样的：</div><div>1.CPU通过各类汇编指令访问内部寄存器</div><div>2.CPU要访问设备的寄存器时，就像访问内存一样，要先知道地址</div><div>举例：</div><div>外部寄存器的地址是0x1000,要读它，使用如下汇编指令：</div><div>Mov R0,#0x1000       @把外部寄存器地址值赋给CPU内部寄存器r0</div><div>Ldr R1,R0</div><h2>3.7 PC寄存器和LR寄存器的理解与区别</h2><div>PC本质上是为CPU服务的，解决的问题是&quot;去哪里&quot;。CPU只需要一个目的地, 然后去就好了。   </div><div>LR本质上是为了给程序员减负。  </div><div>如果没有LR，当caller想调用calle时，caller就必须定义一个参数return_addr，然后把这个参数传递给callee, 这样callee才能够返回到caller。 </div><div>但现在有了LR，在硬件层面上就定死了返回地址一定在LR。当caller调用callee时，硬件会自动把返回地址保存到LR, callee也知道它要返回的地址必定在LR。这样程序员就可以任意调用函数，而不必再担心返回地址的问题了。 </div><div><br/></div><div><br/></div><div>1. caller调用callee时，PC和LR的关系:        </div><div>callee的代码执行完后，需要return回caller,   此时的return, 本质上就是 MOV PC, LR   </div><div>2. CPU正在执行函数A时，</div><div>中断X产生了，于是CPU跑去执行中断X的函数, 此时PC和LR的关系：     中断X的代码执行完后，需要return回函数A, 此时的return,  本质上就是 MOV PC, LR </div><h2>3.8 参考资料</h2><div>ARM汇编中PC寄存器详解<a href="https://www.cnblogs.com/ichunqiu/p/9056630.html">https://www.cnblogs.com/ichunqiu/p/9056630.html</a></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 