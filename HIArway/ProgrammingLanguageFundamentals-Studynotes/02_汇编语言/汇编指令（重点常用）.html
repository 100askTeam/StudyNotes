<html>
<head>
  <title>汇编指令（重点|常用）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605138 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <meta name="content-class" content="yinxiang.superNote"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="907"/>
<h1>汇编指令（重点|常用）</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2022/1/11 14:50</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/5/6 13:34</i></td></tr>
<tr><td><b>作者：</b></td><td><i>gi51wa2j</i></td></tr>
<tr><td><b>标签：</b></td><td><i>bingo, 汇编, 正文</i></td></tr>
</table>
</div>
<br/>

<div><span><h1>一、ARM汇编概述</h1><div>一开始，ARM公司发布两类指令集：</div><p><b>① ARM指令集</b>，这是32位的，每条指令占据32位，高效，但是太占空间</p><p><b>② Thumb指令集</b>，这是16位的，每条指令占据16位，节省空间</p><p>要节省空间时用Thumb指令，要效率时用ARM指令。</p><p><br/></p><p>一个CPU既可以运行Thumb指令，也能运行ARM指令。</p><p>怎么区分当前指令是Thumb还是ARM指令呢？</p><p>程序状态寄存器中有一位，名为“T”，它等于1时表示当前运行的是Thumb指令。</p><p><br/></p><p>假设函数A是使用Thumb指令写的，函数B是使用ARM指令写的，怎么调用A/B？</p><p>我们可以往PC寄存器里写入函数A或B的地址，就可以调用A或B，</p><p>但是怎么让CPU在执行A函数是进入Thumb状态，在执行B函数时进入ARM状态？</p><p><br/></p><p>做个手脚：</p><p>调用函数A时，让PC寄存器的BIT0等于1，即：PC=函数A地址+(1&lt;&lt;0)；</p><p>调用函数B时，让PC寄存器的BIT0等于0:，即：PC=函数B地址</p><p><br/></p><div>为了解决这类麻烦的事情，引入<b>Thumb2指令集</b>，</div><p>它支持16位指令、32位指令混合编程。</p><p><br/></p><div><b>问：三种指令集，我们是否需要全部会？如何区分？</b></div><div>ARM公司推出了： Unified Assembly Language</div><p>UAL，统一汇编语言，你不需要去区分这些指令集。</p><p>在程序前面用CODE32/CODE16/THUMB表示指令集:</p><p>ARM/Thumb/Thumb2</p><h2>1.1 如何学习汇编</h2><div>日常工作中，</div><p>只需要这么几条汇编指令，从名字就可以猜出含义：</p><p> <b>常用汇编指令格式及使用</b>在此列出</p><img src="汇编指令（重点常用）_files/Image.png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div>有需要再学习即可，无需花费大量时间去学些这类知识，需要即可百度</div><div>若很感兴趣，参考《ARM Cortex-M3与Cortex-M4权威指南.pdf》</div><img src="汇编指令（重点常用）_files/Image [1].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>二、汇编指令的格式</h1><div>汇编指令可以分为几大类：数据处理、内存访问、跳转、饱和运算、其他指令</div><h2>1.1 指令格式（1）</h2><div>汇编指令的格式，如下：</div><div style="--en-callout:true;"><div>label：                 </div><div>    instruction @ comment</div></div><div><span style="background-color: #d9d9d9;">label</span>，即标签，表示地址位置，可以通过label得到指令/数据地址</div><div><span style="background-color: #d9d9d9;">instruction</span>，即指令，表示汇编指令或伪指令</div><div><span style="background-color: #d9d9d9;">@ comment</span>，@表示后面是注释，comment表示注释内容</div><div>比如：</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">addnum:                               
    mov r0, #0 @ 将R0寄存器设置成0</div><div>上面汇编代码中，<span style="background-color: #d9d9d9;">addnum</span>表示标签，<span style="background-color: #d9d9d9;">mov r0, #0</span>表示指令，<span style="background-color: #d9d9d9;">@ 将R0寄存器设置成0</span> 表示  注释</div><h2>1.2 指令格式（2）</h2><div style="--en-callout:true;"><div>Operation{cond} {S}  Rd,  Rn,  Operand2</div></div><div>Operation：表示各类汇编指令，比如ADD，MOV；</div><div>cond：表示condition，即该指令执行的条件；</div><div>S表示该指令执行后，会去修改程序状态寄存器；</div><p>Rd为目的寄存器，用来存储运算的结果；</p><p>Rn、Operand2是两个源操作数</p><h3>1.2.1 Operation </h3><img src="汇编指令（重点常用）_files/Image [2].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>1.2.2 cond取值</h3><img src="汇编指令（重点常用）_files/Image [3].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>三、汇编指令学习(基础)</h1><a href="汇编指令（重点常用）_files/03_ARM汇编.pptx"><img src="汇编指令（重点常用）_files/4f7a05ca5c5e2c3d05342693bf9ddc2c.png" alt="03_ARM汇编.pptx"></a><a href="汇编指令（重点常用）_files/04_ARM汇编模拟器VisUAL.pptx"><img src="汇编指令（重点常用）_files/349c6db3d9caec7b3df1ada4b1e88b06.png" alt="04_ARM汇编模拟器VisUAL.pptx"></a><a href="汇编指令（重点常用）_files/05_内存访问指令.pptx"><img src="汇编指令（重点常用）_files/b869c7afdd511c4d799cf3e1f4131a09.png" alt="05_内存访问指令.pptx"></a><a href="汇编指令（重点常用）_files/06_数据处理指令.pptx"><img src="汇编指令（重点常用）_files/6b12a64175d0714c9f06ea62a96af23b.png" alt="06_数据处理指令.pptx"></a><a href="汇编指令（重点常用）_files/07_跳转指令.pptx"><img src="汇编指令（重点常用）_files/c321003beccda432960e5c15eedcde7c.png" alt="07_跳转指令.pptx"></a><h2>2.1 内存访问指令</h2><div>读内存指令LDR/LDM：参考《DEN0013D_cortex_a_series_PG.pdf》P340、P341</div><p>写内存指令STR/STM：参考《DEN0013D_cortex_a_series_PG.pdf》P377、P378</p><p><span style="background-color: #fff199;">LDR：Load Register；</span></p><p><span style="background-color: #fff199;">LDM：Load Multiple Register；</span></p><p><span style="background-color: #fff199;">STR：Store Register；</span></p><p><span style="background-color: #fff199;">STM：Store Multiple Register。</span></p><h3>2.1.1 LDR指令</h3><div><b>LDR</b>：L表示LOAD，LOAD的含义应该理解为：Load from memory into register。下面这条语句就说明的很清楚：</div><p>　　LDR   R1,     [R2]</p><p>　　R1&lt;——[R2]</p><p>　　就是把R2所指向的存储单元的内容的值（一个memory地址内的值），读取到R1中（一个register）</p><img src="汇编指令（重点常用）_files/Image [4].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="433px"/><h3>2.1.2 STR指令</h3><div><b>STR</b>：S表示STORE，STORE的含义应该理解为：Store from a register into memory。下面这条语句表示的很清楚：</div><p style="text-align:start;">　　STR    R1,     [R2]</p><p style="text-align:start;">　　R1——&gt;[R2]</p><p style="text-align:start;">　　就是把寄存器R1中的内容“保存”到R2所指向的存储的单元中（一个memory地址）</p><img src="汇编指令（重点常用）_files/Image [5].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="--en-callout:true;"><div><b>STR与LDR的区别</b></div></div><p style="padding-left:40px;text-align:start;">这两条语句都有个特点，就是寄存器写在前面（左边）而内存地址写在后面（右边），数据传送的方向则是恰好相反的。</p><h3>2.1.3 LDM指令</h3><div><b>LDM：</b>L的含义仍然是LOAD，即是Load from memory into register。</div><p style="text-align:start;">　　虽然貌似是LDR的升级，但是，千万要注意，这个指令运行的方向和LDR是不一样的，是从左到右运行的。该指令是将内存中堆栈内的数据，批量的赋值给寄存器，即是出栈操作；其中<b>堆栈指针</b>一般对应于SP，注意SP是寄存器R13，实际用到的却是R13中的内存地址，只是该指令没有写为[R13]，同时，LDM指令中寄存器和内存地址的位置相对于前面两条指令改变了，下面的例子：</p><p style="text-align:start;">　　LDMFD     SP! ,   {R0, R1, R2}</p><p style="text-align:start;">　　实际上可以理解为：    LDMFD     [SP]!,    {R0, R1, R2}</p><p style="text-align:start;">　　意思为：把sp指向的3个连续地址段（应该是3*4=12字节（因为为r0,r1,r2都是32位））中的数据拷贝到r0,r1,r2这3个寄存器中去；</p><img src="汇编指令（重点常用）_files/Image [6].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h3>2.1.4 STM指令</h3><div><b>STM：</b>S的含义仍然是STORE，与LDM是配对使用的，其指令格式上也相似，即区别于STR，是将堆栈指针写在左边，而把寄存器组写在右边。</div><p style="text-align:start;">　　STMFD  SP!,   {R0}</p><p style="text-align:start;">　　该指令也可理解为：  STMFD  [SP]!,  {R0}</p><p style="text-align:start;">　　意思是：把R0保存到堆栈（sp指向的地址）中。</p><img src="汇编指令（重点常用）_files/Image [7].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><div style="--en-callout:true;"><div><b>LDM与STM的区别</b></div></div><div>这两个堆栈操作指令也有个特点，就是寄存器组写在后面（右边）而堆栈指针写在前面（左边），而且实际上使用的是堆栈指针中的内存地址，这一点与前面两条指令是有区别的。</div><p style="text-align:start;"><span style="color: #FF0000;">（补充：sp后面的！的作用：R0的值在ldm过程中发生的增加或减少，最后写回到R0中去，也就是ldm时会改变R0的值）</span></p><h3>2.1.5 LDM与STM的地址模式</h3><p style="text-align:start;"><span style="color: #FF0000;"><span style="background-color: #fff199;"><b>addr_mode:</b></span></span></p><ul><li><p>IA - Increment After,  每次传输后才增加Rn的值<b>(默认,可省)</b></p></li><li><p>IB - Increment Before, 每次传输前就增加Rn的值<b>(ARM指令才能用)</b></p></li><li><p>DA – Decrement After,  每次传输后才减小Rn的值<b>(ARM指令才能用)</b></p></li><li><p>DB – Decrement Before, 每次传输前就减小Rn的值</p></li><li><p>! : 表示修改后的Rn值会写入Rn寄存器, 如果没有&quot;!&quot;, 指令执行完后Rn恢复/保持原值</p></li><li><p>^ : 会影响CPSR, 在讲异常时再细讲</p></li></ul><img src="汇编指令（重点常用）_files/Image [8].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>2.2 分支跳转指令</h2><div>跳转指令用于实现程序流程的跳转，在 ARM 程序中有两种方法可以实现程序流程的跳转：</div><p style="padding-left:40px;text-align:start;"><b><span style="font-weight: 700;">(1) 直接向程序计数器 PC 写入跳转地址值。</span></b></p><p style="padding-left:40px;text-align:start;">通过向程序计数器 PC 写入跳转地址值，可以实现在 4GB 的地址空间中的任意跳转，在跳转之前结合使用</p><p style="padding-left:40px;text-align:start;">MOV LR ， PC</p><p style="padding-left:40px;text-align:start;"><b><span style="font-weight: 700;">(2) 使用专门的跳转指令。</span></b></p><div>参考《DEN0013D_cortex_a_series_PG.pdf》P327、P328、P329</div><p>核心指令是B、BL：</p><p><span style="background-color: #fff199;">B：Branch，跳转</span></p><p><span style="background-color: #fff199;">BL：Branch with Link，跳转前先把返回地址保持在LR寄存器中</span></p><p><span style="background-color: #fff199;">BX：Branch and eXchange，根据跳转地址的BIT0切换为ARM或Thumb状态(0：ARM状态，1：Thumb状态)</span></p><p><span style="background-color: #fff199;">BLX：Branch with Link and eXchange </span></p><p><span style="background-color: #fff199;">         根据跳转地址的BIT0切换为ARM或Thumb状态(0：ARM状态，1：Thumb状态)</span></p><h3>2.2.1 B指令</h3><div>B 指令的格式为：</div><p style="padding-left:40px;text-align:start;">B{条件} 目标地址</p><div>B{条件} 目标地址</div><div>B 指令是最简单的跳转指令。一旦遇到一个 B 指令，ARM 处理器将立即跳转到给定的目标地址，从那里继续执行。</div><div>注意<b>存储在跳转指令中的实际值是相对当前PC 值的一个偏移量，而不是一个绝对地址</b>，它的值由汇编器来计算（参考寻址方式中的相对寻址）。它是 24 位有符号数，左移两位后有符号扩展为 32 位，表示的有效偏移为 26 位(前后32MB 的地址空间)。以下指令：</div><p><br/></p><p>B Label ；程序无条件跳转到标号 Label 处执行</p><p>CMP R1 ，＃ 0 ；当 CPSR 寄存器中的 Z 条件码置位时，程序跳转到标号 Label 处执行</p><p>BEQ Label</p><img src="汇编指令（重点常用）_files/Image [9].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="350px"/><div><span style="color: #FF0000;">.W是一个可选的指令宽度说明符，用于强制要求在 Thumb-2 中使用 32 位 B 指令。</span></div><h3>2.2.2 BL指令</h3><div>BL 指令的格式为：</div><p>BL{条件} 目标地址</p><p>       BL 是另一个跳转指令，但跳转之前，会在寄存器R14 中保存PC 的当前内容，因此，可以通过将R14 的内容重新加载到PC 中，来返回到跳转指令之后的那个指令处执行。该指令是实现子程序调用的一个基本但常用的手段。以下指令：</p><p>BL Label ；当程序无条件跳转到标号 Label 处执行时，同时将当前的 PC 值保存到 R14 中</p><img src="汇编指令（重点常用）_files/Image [10].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="160px"/><h3>2.2.3 BX指 </h3><div><span style="background-color: #ffffff;"><span style="font-weight: 400;">BX 指令的格式为：</span></span></div><p style="text-align:start;">BX{条件} 目标地址</p><p style="text-align:start;">         BX 指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM 指令，也可以是Thumb指令。</p><img src="汇编指令（重点常用）_files/Image [11].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="264.1123595505618px"/><h3>2.2.4 BLX指令</h3><div>BLX 指令的格式为：</div><p>BLX 目标地址</p><p>       BLX 指令从ARM 指令集跳转到指令中所指定的目标地址，并将处理器的工作状态有ARM 状态切换到Thumb 状态，该指令同时将PC 的当前内容保存到寄存器R14 中。因此，当子程序使用Thumb 指令集，而调用者使用ARM 指令集时，可以通过BLX 指令实现子程序的调用和处理器工作状态的切换。</p><p>同时，子程序的返回可以通过将寄存器R14 值复制到PC 中来完成。</p><img src="汇编指令（重点常用）_files/Image [12].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="224px"/><h2>2.3 立即数</h2><div>这样一条指令：</div><p>    MOV   R0, #VAL</p><p>意图是把VAL这个值存入R0寄存器。</p><p>问：VAL可以是任意值吗？</p><p><b>答：不可以，必须是立即数。假设VAL可以是任意数，”MOV  R0, #VAL”本身是16位或32位，哪来的空间保存任意数值的VAL？</b></p><p><b>        所以，VAL必须符合某些规定。</b></p><img src="汇编指令（重点常用）_files/Image [13].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h2>2.4 伪指令（常用）</h2><h3>2.4.1 LDR伪指令</h3><p>想把任意数值赋给R0，可以使用伪指令：</p><p>            LDR   R0,  =VAL</p><p><span style="color: #FF0000;"><b>“伪指令”，就是假的、不存在的指令。</b></span></p><p>注意LDR作为“伪指令”时，<b>指令中有一个“=</b>”，否则它就是真实的LDR(load regisgter)指令了。</p><p><b>编译器读取伪指令时的操作：</b></p><p>编译器会把“伪指令”替换成真实的指令，比如：</p><ul><li><p><b>数值符合立即数规则的情况</b></p></li></ul><p><code style="-en-code: true">LDR  R0,  =0x12</code>    </p><p>0x12是立即数，那么替换为：MOV  R0,  #0x12</p><ul><li><p><b>数值不符合立即数规则的情况</b></p></li></ul><p><code style="-en-code: true">LDR  R0, =0x12345678</code></p><p>0x12345678不是立即数，那么替换为：</p><p>LDR  R0, [PC, #offset]          // 2. 使用Load Register读内存指令读出值，offset是链接程序时确定的</p><p>……</p><p>Label  DCD  0x12345678    // 1. 编译器在程序某个地方保存有这个值</p><div>如果一定需要赋值一个数，但是又不符合立即数的规则，那么就可以使用伪指令</div><h3>2.4.2 ADR伪指令</h3><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div><span style="font-weight: bold;">   </span> 语法格式： ADR {cond}  reg，expr</div><p style="text-align:start;">    其中：cond——可选的指令执行条件。</p><p style="text-align:start;">                reg——目标寄存器。</p><p style="text-align:start;">                expr——基于PC或基于寄存器的地址表达式。</p></div><div> ADR伪指令将基于PC相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中。在汇编编译器编译源程序时，ADR伪指令被编译器替换成一条合适的指令。通常，编译器用一条ADD指令或SUB指令来实现该ADR伪指令的功能，若不能用一条指令实现，则产生错误，编译失败。</div><p>　　　　ADR伪指令格式 ：ADR{cond}   register, expr  </p><p>　　　　　　地址表达式expr的取值范围：</p><p style="text-align:start;">    　　　　　　当地址值是字节对齐时，其取指范围为: +255 ～ 255B；</p><p style="text-align:start;">    　　　　　　当地址值是字对齐时，其取指范围为:   -1020 ～ 1020B；</p><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><p style="text-align:start;"><a href="https://blog.csdn.net/l_andy/article/details/63686870" rev="en_rl_none">字对齐和字节对齐</a></p></div><div style="text-align:center;"><br/></div><div style="text-align:center;"><b>ARM编译器与GCC编译器语法差别</b></div><img src="汇编指令（重点常用）_files/Image [14].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;"/><h1>四、汇编指令学习（常用）</h1><div><br/></div><div><span style="background-color: #ffff00;">常用的汇编指令一般有mov、bl/b、add/sub、ldm/stm、push/pop等等，下面一一介绍。</span></div><h2>4.1 MOV指令</h2><div><span style="background-color: #ffff00;"><b>Move register or constant，</b></span><b>把某个寄存器的值移给另一个寄存器，或是把一个常数移入寄存器</b>。</div><div style="--en-blockquote:true;box-sizing: border-box; padding-left: 19px; padding-top: 6px; padding-bottom: 6px; border-left: 3px solid #b4c0cc; background-position: initial initial; background-repeat: initial initial; margin-top: 6px"><div>mov r1, #10  @ 将10赋值给寄存器r1，即r1=10</div></div><div>  指令执行过程，如下：</div><img src="汇编指令（重点常用）_files/Image [15].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="531px"/><div style="padding-left:40px;"><b>1. 取址</b></div><div style="padding-left:40px;">假设从内存的addrA地址取机器码e3a0100a（即mov r1, #10指令）</div><div style="padding-left:40px;"><b>2. 译码</b></div><div style="padding-left:40px;">原来是MOV指令</div><div style="padding-left:40px;"><b>3. 执行</b></div><div style="padding-left:40px;">CPU内部寄存器R1等于10</div><div>其中，机器码e3a0100a，MOV指令各位的解析如下：</div><img src="汇编指令（重点常用）_files/Image [16].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="829px"/><div>[31:28]位是条件码0xe；[15：12]位是寄存器R1，即0x1；[12:0]位是立即数10，即0x00a</div><h2>4.2 BL指令</h2><div><span style="background-color: #ffff00;"><b>Branch with Link，跳转并把返回地址记录在LR寄存器里。</b></span></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;"> bl test_tag
 mov r1, #10
 
test_tag:
mov r3, #0
 mov pc, lr</div><div>第1行，跳转到test_tag标签处执行“mov r3, #0”指令，并且将<b>下一条指令即“mov  r1, #10”指令的地址存储到 LR 寄存器。</b></div><div>第6行，返回到“mov r1, #10”指令地址，并且执行“mov r1, #10”指令</div><div>指令执行过程，如下：</div><img src="汇编指令（重点常用）_files/Image [17].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="829px"/><div><br/></div><div>1. CPU从内存的addrA地址取机器码eb000000（即“bl test_tag”指令），执行后，PC跳转到test_tag标签位置，即内存的addrA+8地址，从上图可知，其实test_tag标签的地址是“mov r3, #0”指令的地址。同时自动将内存的addrA+4地址存储在寄存器LR中。</div><div>2. CPU从内存的addrA+8地址取机器码e3a03000（即“mov r3, #0”指令），执行，CPU内部寄存器R3等于0。</div><div>3. CPU从内存的addrA+12地址取机器码e1a0f00e（即“mov pc, lr”指令），执行，PC跳转到内存的addrA+4地址。</div><div>4. CPU从内存的addrA+4地址取机器码e3a0100a（即“mov r1, #10”指令），执行，CPU内部寄存器R1等于10</div><div><b>其中，机器码eb000000，BL指令各位的解析如下：</b></div><img src="汇编指令（重点常用）_files/Image [18].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="829px"/><div><span style="background-color: #ffff00;"><b>imm[23:0]是PC值与标签的偏移值除以4，但是此处的偏移值是0，为什么呢？</b></span>这是因为ARM采用三级流水线的方法，即取指、译码、执行指令。所以当ARM执行addrA地址的“bl  test_tag”指令时，但是PC已经指向addrA+8地址进行取“mov r3, #0”指令，也就是PC值等于当前指令地址加8，<b>所以要跳去执行“addrA+8”的指令，偏移值就要设置为0</b>：执行这条bl指令后，新的PC=PC+偏移，刚好就是“addrA+8”。</div><h2>4.2 B指令</h2><div><span style="background-color: #ffff00;"><b>Branch，跳转指令。相比于BL指令，它并不保存下一条指令的地址到LR寄存器。</b></span></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">b test_tag
mov r1, #10

test_tag:
mov r3, #0</div><div>第1行，只是跳转到test_tag标签处执行“mov r3, #0”指令，没有保存返回地址。</div><div><b>指令B与指令BL，大同小异，此处就不一一分析了，可以参数指令BL，它们的区别：BL指令的下一条指令的地址会被存储到LR寄存器，而B指令不会存储。</b></div><h2>4.3 ADD/SUB指令</h2><div><span style="background-color: #ffff00;"><b>加法、减法指令。</b></span></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">mov r1, #10
add r2, r1, #4
sub r2, r1, #4</div><div>第2行，r2 = r1 + 4。</div><div>第3行，r2 = r1 - 4。</div><div><br/></div><div>指令执行过程，如下：</div><img src="汇编指令（重点常用）_files/Image [19].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="828px"/><div>CPU从内存的addrA+4地址取机器码e2812004（即add r2, r1, #4指令），执行后，CPU内部寄存器R2等于14</div><div>CPU从内存的addrA+8地址取机器码e2412004（即sub r2, r1, #4指令），执行后，CPU内部寄存器R2等于6</div><div>其中，机器码e2812004，ADD指令各位的解析如下：</div><img src="汇编指令（重点常用）_files/Image [20].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="829px"/><div>[19: 16]位是源寄存器R1，即1；[15: 12]位是目标寄存器R2，即2；[11: 0]位是立即数4，即0x004；</div><div><br/></div><div>其中，机器码e2412004，SUB指令各位的解析如下：</div><img src="汇编指令（重点常用）_files/Image [21].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="829px"/><div>[19: 16]位是源寄存器R1，即1；[15: 12]位是目标寄存器R2，即2；[11: 0]位是立即数4，即0x004；</div><div><br/></div><h2>4.4 LDR/STR指令</h2><div><span style="background-color: #ffff00;"><b>Store register to memory/Load register from memory，前者是把寄存器的值写入内存，后者是读内存到寄存器。</b></span></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">mov r0, #400H @ 0x400
mov r1, #aH   @ 0xa
str r1, [r0]
ldr r2, [r0]</div><div>第3行，将寄存器R1的值0xa存储到寄存器R0指向的地址0x400，即内存0x400地址的值为0xa</div><div>第4行，将寄存器R0指向地址0x400的数据赋值给寄存器R2，即CPU内部寄存器R2等于0xa</div><div><br/></div><div>指令执行过程，如下：</div><div><br/></div><img src="汇编指令（重点常用）_files/Image [22].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="823px"/><div><br/></div><div><br/></div><div><span style="background-color: #ffff00;">1. CPU从内存的addrA 地址取机器码e3a00b01（即mov r0, #400H指令），<b>执行后，CPU内部寄存器R0等于0x400</b></span></div><div><span style="background-color: #ffff00;">2. CPU从内存的addrA+4地址取机器码e3a0100a（即mov r1, #aH指令），<b>执行后，CPU内部寄存器R1等于0xa</b></span></div><div><span style="background-color: #ffff00;">3. CPU从内存的addrA+8地址取机器码e5801000（即str r1, [r0]指令），执行后，寄存器R1的0xa数据存储到寄存器R0指向的地址0x400，<b>即内存的0x400地址的值为0xa（结论正确，但是前文描述不准确）</b></span></div><div><span style="background-color: #ffff00;">4. CPU从内存的addrA+12地址取机器码e5902000（即ldr r2, [r0]指令），执行后，寄存器R0指向的地址0x400的数据存储到CPU内部寄存器R2，<b>即CPU内部寄存器R2等于0xa（结论正确，但是前文描述不准确）</b></span></div><div> <span style="color: #FF0000;"> 注意源寄存器和目标寄存器位置</span></div><div>其中，机器码e5801000<b>，STR指令各位的解析如下：</b></div><div><b>STR语法中是：源寄存器+目标寄存器</b></div><img src="汇编指令（重点常用）_files/Image [23].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="822px"/><div>[19: 16]位是目标寄存器R0，即0；[15: 12]位是源寄存器R1，即1；</div><div><br/></div><div>其中，机器码e5902000，<b>LDR指令各位的解析如下：</b></div><div><b>LDR语法中是：目标寄存器+源寄存器</b></div><img src="汇编指令（重点常用）_files/Image [24].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="822px"/><div>[19: 16]位是源寄存器R0，即0；[15: 12]位是目标寄存器R2，即2；</div><h2>4.5 LDR伪指令</h2><div><b>所谓“伪指令”就是假的、不真实存在的指令。编译器会用真正的指令来代替它。</b></div><div><span style="background-color: #ffff00;">Ldr指令的参数中，有“=”时，它就是伪指令，不再是上小节讲的“读内存”指令了。</span></div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">ldr sp,=0x80200000</div><div>这个是一条伪指令，即实际中并不存在这个指令，它会被拆分成几个真正的ARM指令，<b>实现一样的效果，将0x80200000赋值给寄存器sp，即sp=0x80200000。</b></div><div>指令执行过程，如下：</div><div>   </div><img src="汇编指令（重点常用）_files/Image [25].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="830px"/><div>ldr sp,=0x80200000这条伪指令，被翻译成一条指令来执行：<span style="background-color: #ffff00;"> ldr sp, [pc, #-4]。它是一条读内存指令，显然，在“pc-4”这个地址对应的内存里存有0x80200000这个数值。</span>这是编译器预先把0x80200000设置在这个地址的。</div><h2>4.6 LDM/STM指令</h2><div><span style="background-color: #ffff00;"><b>ldm，Load multiple registers，从内存里把值加载进多个寄存器。</b></span></div><div>stm，Store Multiple，把多个寄存器的值存储到内存。</div><div>格式：  </div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">ldm{cond} Rn{!}, reglist
stm{cond} Rn{!}, reglist</div><div>参数说明：  </div><div><span style="color: #FF0000;">cond：如下所示，下面列出的前四个条件是用于数据块操作，后四个条件是用于堆栈操作：</span></div><div><span style="color: #FF0000;">IA : Increment After，先传输再增加地址</span></div><div><span style="color: #FF0000;">IB : Increment Before，先增加地址再传输</span></div><div><span style="color: #FF0000;">DA : Decrement After，先传输再减小地址</span></div><div><span style="color: #FF0000;">DB : Decrement Before，先减小地址再传输</span></div><div><span style="color: #FF0000;">FD : 满递减堆栈</span></div><div><span style="color: #FF0000;">FA : 满递增堆栈</span></div><div><span style="color: #FF0000;">ED : 空递减堆栈</span></div><div><span style="color: #FF0000;">EA : 空递增堆栈</span></div><div><span style="color: #FF0000;">Rn：基址寄存器，里面含有内存的起始地址。</span></div><div><span style="color: #FF0000;">！：表示最后的地址写回到Rn中。</span></div><div><span style="color: #FF0000;">reglist：里面列出多个寄存器，如{R1,R2,R6-R9}。</span></div><div><span style="background-color: #ffff00;"><b>注意</b>：传输数据时，低号寄存器对应低地址，高号寄存器对应高地址。</span></div><div>示例：  </div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">ldr r1,=0x10000000     

ldmib r1!, {r0,r4-r6}
stmda r1!, {r0,r4-r6}</div><div style="padding-left:80px;"><b>第1行，</b>将起始地址0x10000000赋值给r1</div><div style="padding-left:80px;"><b>第3行</b>，因为使用ib，所以每次传送前地址加4，具体操作如下(低地址的值存入低号寄存器)：</div><div>将0X10000004地址的内容赋值给R0</div><div>将0X10000008地址的内容赋值给R4</div><div>将0X1000000C地址的内容赋值给R5</div><div>将0X10000010地址的内容赋值给R6</div><div style="padding-left:40px;">“!”表示，最后的地址写回到R1中，R1=0X10000010</div><div style="padding-left:80px;"><b>第4行</b>，因为使用da，所以每次传送后地址减4，具体操作如下(低号寄存器的值存入低地址)：</div><div>将R6存储到0X10000010地址</div><div>将R5存储到0X1000000C地址</div><div>将R4存储到0X10000008地址</div><div>将R0存储到0X10000004地址</div><div>“!”表示，最后的地址写回到R1中，R1=0X10000000</div><div style="padding-left:40px;">如下图所示：</div><img src="汇编指令（重点常用）_files/Image [26].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="180px"/><h3>4.6.1 堆栈操作：满递减堆栈 </h3><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">ldr sp,=0x80200000

stmfd sp!, {r0-r2} @ 入栈
ldmfd sp!, {r0-r2} @ 出栈</div><div style="padding-left:80px;"><b>第1行，</b>将0x80200000赋值给sp，作为堆栈的起始地址</div><div style="padding-left:80px;"><b>第3行，</b>入栈，具体操作如下：</div><div>将R2存储到0X80200000地址</div><div>将R1存储到0X801FFFFC地址</div><div>将R0存储到0X801FFFF8地址</div><div style="padding-left:80px;"><b>第4行，</b>出栈，具体操作如下：</div><div>将0X801FFFF8地址的内容赋值给R0</div><div>将0X801FFFFC地址的内容赋值给R1</div><div>将0X80200000地址的内容赋值给R2</div><div>  </div><div>如下图所示：</div><img src="汇编指令（重点常用）_files/Image [27].png" type="image/png" data-filename="Image.png" style="--en-uploadstate:uploaded;" width="397px"/><div>上述第3，4行汇编代码，就是所谓的入栈，出栈。<span style="background-color: #ffff00;">也可以用push，pop指令完成入栈，出栈，</span>如下</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">ldr sp,=0x80200000

push {r0-r2} @ 入栈
pop {r0-r2}  @ 出栈LDR</div><h3>4.6.2 参考资料</h3><div><a href="http://c.biancheng.net/view/3534.html">http://c.biancheng.net/view/3534.html</a></div><h2>4.7 ALIGN 指令</h2><div>语法如下：</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">ALIGN bound</div><div>     Bound 可取值有：1、2、4、8、16。当取值为 1 时，则下一个变量对齐于 1 字节边界（默认情况）。当取值为 2 时，则下一个变量对齐于偶数地址。当取值为 4 时，则下一个变量地址为 4 的倍数。当取值为 16 时，则下一个变量地址为 16 的倍数，即一个段落的边界。</div><div style="text-align:start;">     为了满足对齐要求，汇编器会在变量前插入一个或多个空字节。为什么要对齐数据？因为，对于存储于偶地址和奇地址的数据来说，CPU 处理偶地址数据的速度要快得多。</div><div style="text-align:start;">     下述例子中，bVal 处于任意位置，但其偏移量为 0040 4000。在 wVal 之前插入 ALIGN 2 伪指令，这使得 wVal 对齐于偶地址偏移量：</div><div style="--en-codeblock:true;--en-codeblockLanguage:clike;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial; margin-top: 6px;">
bVal BYTE ?           ;00404000h
ALIGN 2 
wVal WORD ?           ;00404002h
bVal2 BYTE ?          ;00404004h
ALIGN 4 
dVal DWORD ?          ;00404008h
dVal2 DWORD ?         ;0040400Ch</div><div>请注意，dVal 的偏移量原本是 0040 4005，但是 ALIGN 4 伪指令使它的偏移量成为 0040 4008。</div></span>
</div></body></html> 